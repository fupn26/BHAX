<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
        <para>
            A módosított polártranszformációs normális generátor beprogramozása Java nyelven. Mutassunk rá,
            hogy a mi természetes saját megoldásunk (az algoritmus egyszerre két normálist állít elő, kell egy
            példánytag, amely a nem visszaadottat tárolja és egy logikai tag, hogy van-e tárolt vagy futtatni kell
            az algot.) és az OpenJDK, Oracle JDK-ban a Sun által adott OO szervezés ua.!
        </para>
        <para>
            <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf">https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf(16-22 fólia)</link>
        </para>
        <para>
            Ugyanezt írjuk meg C++ nyelven is! (lásd még UDPROG repó: source/labor/polargen)                
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/Pol%C3%A1rGen">itt</link>
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A korábbi fejezetben már megismertük mind a C++, mind a Java forrást. Most azt fogjuk megnézni, hogy a hivatalos Java
            <function>random</function> szám generátor mennyiben hasonlít a mi megoldásunkra. 
        </para>
        <para>
            Elsőnek nézzük ár újra a Java forrást,
            <programlisting language="java"><![CDATA[
public class PolarGenerator
{
    boolean nincsTarolt = true;
    double tarolt;
    
    public PolarGenerator()
    {
        nincsTarolt = true;
    }
    
    public double kovetkezo() 
    {
        if(nincsTarolt)
        {
            double u1, u2, v1, v2, w;
            do{
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2* u1 -1;
                v2 = 2* u2 -1;
                w = v1*v1 + v2*v2;
            } while (w>1);
            
            double r = Math.sqrt((-2 * Math.log(w) / w));
            tarolt = r * v2;
            nincsTarolt = !nincsTarolt;
            return r * v1;
        }
        else
        {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
}
            ]]></programlisting>
        </para>
        <para>
            Tehát a program annyit csinál, hogy generál 2 random számot. Az egyiket eltárolja, a másikat pedig visszaadja.
            Elsőnek meg kell viszgálni, hogy van-e tárolt elem. Ehhez szükségünk van a <function>nincsTarolt</function>
            logikai változóra, mely alapértelmezetten igaz. Majd a <function>double</function> függvény, abban az esetben
            ha ez a változó igaz értékű, akkor kiszámolja a két random számot. Eltárolja az egyiket, majd a
            <function>nincsTarolt</function>-t hamisra állítja. Így elkerülhetjük azt, hogy a programnak feleslegesen kelljen
            újra random számot generálnia. 
        </para>
        <para>
            Most, hogy láttuk, hogyan működik a saját Polár generátorunk, nézzük, hogy a OpenJDK <filename>Random.java</filename>
            forrásában, hogyan oldották meg ezt.
            <programlisting language="java"><![CDATA[
    private double nextNextGaussian;
    private boolean haveNextNextGaussian = false;
                
    public synchronized double nextGaussian() {
        // See Knuth, ACP, Section 3.4.1 Algorithm C.
        if (haveNextNextGaussian) {
            haveNextNextGaussian = false;
            return nextNextGaussian;
        } else {
            double v1, v2, s;
            do {
                v1 = 2 * nextDouble() - 1; // between -1 and 1
                v2 = 2 * nextDouble() - 1; // between -1 and 1
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s == 0);
            double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
            nextNextGaussian = v2 * multiplier;
            haveNextNextGaussian = true;
            return v1 * multiplier;
        }
    }

            ]]></programlisting>
            Ahogy láthatjuk a hivatalos megoldás teljesen ugyanaz, mint a mi sajátunk. Ez a feladat arra ad példát, hogy
            az objektumorientált programozás egyáltalán nem annyira nehéz, mint azt sokan gondolják.
        </para>
        <para>
            Végezetül pedig lássuk, újra ennek a C++-os megoldását.
            <programlisting language="c++"><![CDATA[
class PolarGen {

	public:

		PolarGen(); //konstruktor

		~PolarGen(){} //destruktor

		double kovetkezo(); //random lekérés

	private:

		bool nincsTarolt;
		double tarolt; //random értéke

};


PolarGen::PolarGen() { //a konstruktor kifejtése
	nincsTarolt = false;
	std::srand (std::time(NULL)); //random inicializálás
};


double PolarGen::kovetkezo() { //random lekérő függvény kifejtése
	if (nincsTarolt)
{
		double u1, u2, v1, v2, w;

		do{
			u1 = std::rand () / (RAND_MAX + 1.0); //innentől jön az algoritmus
			u2 = std::rand () / (RAND_MAX + 1.0);
			v1 = 2 * u1 - 1;
			v2 = 2 * u2 - 1;
			w = v1 * v1 + v2 * v2;
		    }
		while (w > 1);

		double r = std::sqrt ((-2 * std::log (w)) / w);

		tarolt = r * v2; 
		nincsTarolt = !nincsTarolt;

		return r * v1; //idáig tart az algoritmus
	}
	
	else
	{
		nincsTarolt = !nincsTarolt; //ha van korábbi random érték, akkor azt adja vissza
		return tarolt;
	}
};    
            ]]></programlisting>
        </para>
    </section>        

    <section>
        <title>Homokózó</title>
        <para>
            Írjuk át az első védési programot (LZW binfa) C++ nyelvről Java nyelvre, ugyanúgy működjön!
            Mutassunk rá, hogy gyakorlatilag a pointereket és referenciákat kell kiirtani és minden máris működik
            (erre utal a feladat neve, hogy Java-ban minden referencia, nincs választás, hogy mondjuk egy
            attribútum pointer, referencia vagy tagként tartalmazott legyen).
        </para>
        <para>
            Miután már áttettük Java nyelvre, tegyük be egy Java Servletbe és a böngészőből GET-es kéréssel
            (például a böngésző címsorából) kapja meg azt a mintát, amelynek kiszámolja az LZW binfáját!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://git.io/Je3cZ">https://git.io/Je3cZ</link>                
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A könyv korábbi részében részletesen elemztük már, hogy hogyan működik az LZW binfa. 
            Megvizsgáltuk a C++ forrás felépítését, és több feladatban módosítottunk is rajta. Most
            viszont az eredeti <filename>z3a7.cpp</filename>-hez nyúlunk vissza, annak fogjuk 
            elkészíteni a Java implementációját, és megismerkedünk azzal is, hogyan lehet ezt 
            Java Servlet-ként böngészőben futtatni. Ahogy a feladat leírásásban olvashatod, 
            elég csak a pointereket és a referenciákat eltüntetni a forrásból. Természetesen ez 
            költői túlzás, de a feladat nem nehéz. 
        </para>
        <para>
            A Java programozási nyelv biztosítja azt, hogy ne kelljen azon gondolkodni, hogy 
            egy objektumot refernciakánt, pointerként, vagy esetleg csak értékként adjuk át.
            Mivel bármilyen objektumot is példányosítunk, az lényegében egy objektumrefernciát hoz
            létre. Kivételt képeznek ezalól a primitív típusok, mint az <function>int, double, char</function> stb.
            Ezekhez a Java nyelv csomagoló osztályokat biztosít, mint például az <function>Integer</function>,
            melyet már objektumreferenciaként példányosítjuk. Még egy fontos megjegyzés, mielőtt tovább haladunk,
            hogy a Java nem támogatja a operátor túlterhelést, szóval ezeket kénytelenek vagyunk
            hagyomásnyos függvényekkel helyettesíteni.
        </para>
        <para>
            Lássuk a forrást:
            <programlisting language="java"><![CDATA[
class LZWBinFa
{
    public LZWBinFa ()
    {
        fa = gyoker;
    }

    public void hozzarendel(char b)
    {
        if (b == '0')
        {
            if (fa.nullasGyermek () == null)
            {
                Csomopont uj = new Csomopont ('0');
                fa.ujNullasGyermek (uj);
                fa = gyoker;
            }
            else			
            {
                fa = fa.nullasGyermek ();
            }
        }
        else
        {
            if (fa.egyesGyermek () == null)
            {
                Csomopont uj = new Csomopont ('1');
                fa.ujEgyesGyermek (uj);
                fa = gyoker;
            }
            else
            {
                fa = fa.egyesGyermek ();
            }
        }
    }
    public void kiir ()
    {
        melyseg = 0;
        kiir (gyoker, new java.io.BufferedWriter(new java.io.OutputStreamWriter(System.out)));
    }

    public int getMelyseg ()
    {
        melyseg = maxMelyseg = 0;
        rmelyseg (gyoker);
        return maxMelyseg - 1;
    }
    public double getAtlag ()
    {
        melyseg = atlagosszeg = atlagdb = 0;
        ratlag (gyoker);
        atlag = ((double) atlagosszeg) / atlagdb;
        return atlag;
    }
    public double getSzoras ()
    {
        atlag = getAtlag ();
        szorasosszeg = 0.0;
        melyseg = atlagdb = 0;

        rszoras (gyoker);

        if (atlagdb - 1 > 0)
            szoras = java.lang.Math.sqrt (szorasosszeg / (atlagdb - 1));
        else
            szoras = java.lang.Math.sqrt (szorasosszeg);

        return szoras;
    }
    public void kiir (java.io.BufferedWriter os)
    {
        melyseg = 0;
        kiir (gyoker, os);
    }

    private class Csomopont
    {
        public Csomopont (char b)
        {
            betu = b;
            balNulla = null;
            jobbEgy = null;
        }
        public final Csomopont nullasGyermek ()
        {
            return balNulla;
        }
        public final Csomopont egyesGyermek ()
        {
            return jobbEgy;
        }
        public void ujNullasGyermek (Csomopont gy)
        {
            balNulla = gy;
        }
        public void ujEgyesGyermek (Csomopont gy)
        {
            jobbEgy = gy;
        }
        public final char getBetu ()
        {
            return betu;
        }

        private char betu;
        private Csomopont balNulla;
        private Csomopont jobbEgy;
    }

    private Csomopont fa;
    private int melyseg, atlagosszeg, atlagdb;
    private double szorasosszeg;

    public void kiir (Csomopont elem, java.io.BufferedWriter os)
    {
        if (elem != null)
        {
            try{
            ++melyseg;
            kiir (elem.egyesGyermek (), os);
            for (int i = 0; i < melyseg; ++i)
                os.write("---");
            os.write(elem.getBetu () + "(" + (melyseg - 1) + ")\n");
            kiir (elem.nullasGyermek (), os);
            --melyseg;
            }
            catch(java.io.IOException e){
                System.out.println("Csomópont írása nem sikerült.");
            }
        }
    }
    protected Csomopont gyoker = new Csomopont('/');
    protected int maxMelyseg;
    protected double atlag, szoras;

    protected void rmelyseg (Csomopont elem)
    {
        if (elem != null)
        {
            ++melyseg;
            if (melyseg > maxMelyseg)
                maxMelyseg = melyseg;
            rmelyseg (elem.egyesGyermek ());
            rmelyseg (elem.nullasGyermek ());
            --melyseg;
        }
    }
    protected void ratlag(Csomopont elem) {
        if (elem != null) {
            ++melyseg;
            ratlag(elem.egyesGyermek());
            ratlag(elem.nullasGyermek());
            --melyseg;
            if (elem.egyesGyermek() == null && elem.nullasGyermek() == null) {
                ++atlagdb;
                atlagosszeg += melyseg;
            }
        }

    }
    protected void rszoras(Csomopont elem) {
        if (elem != null) {
            ++melyseg;
            rszoras(elem.egyesGyermek());
            rszoras(elem.nullasGyermek());
            --melyseg;
            if (elem.egyesGyermek() == null && elem.nullasGyermek() == null) {
                ++atlagdb;
                szorasosszeg += ((melyseg - atlag) * (melyseg - atlag));
            }
        }

    }
            ]]></programlisting>
            Ahogy látható, semmilyen címképző operátorra, vagy csillagra nincs szükség a kódban.
            Maga az osztály konstruktora az nagyon hasonlít az eredetire. Viszont nincs már szükség
            destruktorra. Tehát a C++ forrásban lévő <function>szabadit</function>-ra már nincs szükségünk.
            Ez annak köszönhető, hogy Java szemétgyűjtögetője automatikusan törli azokat az objektumokat a memóriából, amire
            már nincs érvényes referencia. Lehet úgy példányosítani egy osztályt, mint ahogy C++-ban a sima változókat
            deklaráltuk
            <programlisting language="java">
                Csomopont fa;
            </programlisting>
            Ebben az esetben egy <function>null</function> referenciát kapunk, vagyis ennek még át kell adni egy
            bizonyos memóriacímen található objektumot. Jelen esetben ez nem okoz problémát a programban, mert a
            a <function>fa</function> objektumrefernciának átadjuk a <function>gyoker</function> által
            mutatott objektumot. az átírás során én nem inicializáltam a <function>gyoker</function>
            refenciát, így hibát dobott a program, mivel után a <function>fa</function> referencia is
            null referencia maradt, mely által mutatott objektumra hivatkozunk a későbbi függvényekbe.
            C++-hoz hasonlóan a <function>new</function> operátorral tudunk tárhelyet foglalni, mely Java-ban
            referenciát ad át.
        </para>
        <para>
            Az objektumorientált programozás alap építőkövének számító adatrejtés egy kicsit másabb, mint a
            C++-ban megszoktuk. Ahhoz, hogy az egyes tagváltozók és tagfüggvények elérhetőségét szabályozzuk, 
            mindegyik definíciója elé meg kell adni, hogy milyen elérést biztosítsunk hozzájuk. A Java nyelv 
            nem támogatja a operátor túlterhelést, új metódus jelent meg a programban, a 
            <function>hozzarendel</function>. Mostmár ezzel lehet a fába beletteni a nullákat és az egyeseket.
        </para>
        <para>
            Most, hogy már láttuk magát az osztályt, akkor nézzük meg a <function>main</function> függvényt. 
            <programlisting language="java"><![CDATA[
public static void main (String[] args)
{
    if (args.length != 3)
    {
        usage ();
        System.exit(-1);
    }

    String inFile = args[0];

    if (args[1].charAt(1) != 'o')
    {
        System.out.println("Missing -o argument");
        usage ();
        System.exit(-2);
    }

try {
        java.io.FileInputStream beFile = new java.io.FileInputStream(inFile);
        java.io.DataInputStream beFile_datastream = new java.io.DataInputStream(beFile);
        java.io.BufferedReader beFile_bufferedreader = new java.io.BufferedReader(new java.io.InputStreamReader(beFile_datastream));
        
        java.io.FileWriter kiFile = new java.io.FileWriter(args[2]);
        java.io.BufferedWriter kiFile_bufferedwriter = new java.io.BufferedWriter(kiFile);
        LZWBinFa binFa = new LZWBinFa(); // s nyomjuk majd be az LZW fa objektumunkba
        
        int c;
        while ((c = beFile_bufferedreader.read()) != -1){
            if (c == 0x0a) {
                break;
            }
        }
        boolean kommentben = false;

    while ((c = beFile_bufferedreader.read()) != -1)
    {
 
        if (c == 0x3e) {			// > karakter
                kommentben = true;
                continue;
            }

        if (c == 0x0a) {			// újsor
            kommentben = false;
            continue;
        }

        if (kommentben) {
            continue;
        }

        if (c == 0x4e) // N betű
        {
            continue;
        }

        for (int i = 0; i < 8; ++i) {
            if ((c & 0x80) == 128) // ha a vizsgált bit 1, akkor az '1' betűt nyomjuk az LZW fa objektumunkba
            {
                binFa.hozzarendel('1');
            } else // különben meg a '0' betűt:
            {
                binFa.hozzarendel('0');
            }
            c <<= 1;
        }

    }


    binFa.kiir(kiFile_bufferedwriter);
    kiFile_bufferedwriter.write("depth = " + binFa.getMelyseg() + '\n');
    kiFile_bufferedwriter.write("mean = " + binFa.getAtlag()+ '\n');
    kiFile_bufferedwriter.write("var = " + binFa.getSzoras() + '\n');

    kiFile_bufferedwriter.close();
    kiFile.close ();
    beFile_datastream.close ();
    beFile_bufferedreader.close();
    beFile.close();
    } catch (Exception e) {
        for (StackTraceElement elem : e.getStackTrace()) {
            System.err.println(elem);
        }
    }

}
            ]]></programlisting>
            A függvény lénnyegében ugyanazt csinálja, mint korábban. Feltűnhet, hogy már nem 
            4 paraméternek kell lennie, hanem csak 3-nak. Ez abból adódik, hogy Java-ban az
            első paraméter nem a program neve, hanem az álatulnk megadott első paraméter a 
            program neve után. Tehát leellenőrizzük, hogy meg van-e minden szükséges paraméter.
            Ezután jön egy érdekesség, mely a korábbi programban nem volt benne, de gyakorlott
            C++ programozóknak már nem lehet újdonság, ez a <function>try-catch</function> blokk.
            Java-ban a kivételkezelés sok esetben elvárásnak számít. Jelen esetben a fájlkezelés
            miatt volt rá szükség, mivel enélkül le se fordulna a kód. De ezzel az esetleges
            null referenciákra való hivatkozást is ki tudjuk szűrni.
            Első lépésként 
            megnyitjuk a bemenethez és a kimenethez szükséges fájlokat. Ehhez a java.io osztályait
            használjuk. Ezután pedig elkezdjük beolvasni a forrást, és az abban lévő betűk függvényében
            0-kal és 1-kel feltölteni a fát. A <function>for</function> ciklust kellett egy kicsit átalakítani, 
            mivel Java-ban a bájtsorrend big-endian, ezért nem 1-el kell egyenlőnek lennie a
            <function><![CDATA[(c & 0x80)]]></function> kifejezésnek, hanem 128-al, ahhoz, hogy 
            1-est nyomjunk a fába. Majd a fát és annak mélységét, átlagát, szórását kiírjuk a 
            kimenetként kapott fájba. Egy dologra vigyázni kell, hogy a <function>BufferedWriter</function>
            osztály nem azonnal írja ki a fájlba a tartalmat, hanem csak akkor, amikor bezárjuk az 
            általa megnyitott fájlt. Tehát ha ezt elfelejtjük megtenni, akkor azt nem kapjuk meg a
            program eredményét.
        </para>
        <para>
            A feladat második részében pedig átalakítjuk a programot Java 
            Servletté. Ehhez az Apache Tomcat webszervert fogjuk használni. 
            Első lépésként le kell tölteni a legújabb verzióját ennek a 
            szervernek.(<link xlink:href="http://tomcat.apache.org/">http://tomcat.apache.org/</link>)
            Ki kell csomagolni, majd /bin/startup.sh-val tudjuk elindítani a 
            szervert, leállítani pedig a /bin/shutdown.sh-val lehet. A módosított
            java forrásból készített class fájlt
            a /webapps/ROOT/WEB-INF/classes mappába kell helyezni, majd 
            a /webapps/ROOT/WEB-INF/web.xml fájlba el kell helyezni a következő
            sorokat:
            <programlisting language="xml"><![CDATA[
<servlet>
   <servlet-name>LZWBinFa</servlet-name>
   <servlet-class>LZWBinFa</servlet-class>
</servlet>

<servlet-mapping>
   <servlet-name>LZWBinFa</servlet-name>
   <url-pattern>/LZWBinFa</url-pattern>
</servlet-mapping>
            ]]></programlisting>
            Fontos, hogy ezeket a <function>webapp</function> tagak közé kell helyezni.
            Ha ezekkel a lépésekkel kész vagyunk, akkor már lehet futtatni a böngészőben 
            a programot.
            Nézzük meg, hogy milyen módosításokat kellett végezni az eredeti 
            forráson.
            <programlisting language="java">
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;


public class LZWBinFa extends HttpServlet
{
                ...
}
            </programlisting>
            Elsőnek importálni kell a Java Servlethez szükséges csomagokat.
            Ezeket a <function>javac</function> nem találja meg azonnal, mivel 
            a <filename>servlet-api.jar</filename>-t nem tartalmazza a Java
            JDK. Ezt a Tomcat webserverrel együtt kapjuk meg, ezért a classpath-t
            meg kell adni a <function>javac</function> számára. Ehhez a -cp
            kapcsolót használhatjuk.
            <programlisting>
                javac -cp /path/to/apache-tomcat-9.0.xx/lib/servlet-api.jar LZWBinFa.java
            </programlisting>
            A másik, amit egyből észre lehet venni, hogy az osztályunk a 
            HttpServlet osztály leszármazottja. Enélkül nem tudnánk 
            <function>Servlet</function>-ként használni a programot. Az 
            osztályunk konstruktorára már nincs szükség, mivel nincs 
            <function>main</function> függvény sem. A megmaradt 
            tagfüggvények nagy része nem változott. Kivéve a 
            <function>kiir</function> függvényt, mely most a 
            az <function>LZWBinFa</function> tagváltozójába, 
            a <function>kimenet</function>-be építi fel a fát.
            <programlisting language="java"><![CDATA[
    public void kiir (Csomopont elem)
    {
        // Nem létező csomóponttal nem foglalkozunk... azaz ez a rekurzió leállítása
        if (elem != null)
        {

            ++melyseg;
            kiir (elem.egyesGyermek ());
            // ez a postorder bejáráshoz képest
            // 1-el nagyobb mélység, ezért -1
            for (int i = 0; i < melyseg; ++i)
                kimenet.append("---");
            kimenet.append(elem.getBetu () + "(" + (melyseg - 1) + ")<br>\n");
            kiir (elem.nullasGyermek ());
            --melyseg;
            
        }
    } 
            ]]></programlisting>
            A <function>main</function> függvényt a <function>CreateStringBuffer</function>
            váltotta. Lényegében ugyan azt a szerepet látja el, annyi különbséggel, hogy
            ez már egy tagfüggvénye az osztályunknak.
            <programlisting><![CDATA[
public void CreateStringBuffer(String bemenet)
{
    for(int i = 0; i < bemenet.length(); ++i){
        int c = bemenet.charAt(i);
        if(c == 0x0a){
            break;
        }
    }
    boolean kommentben = false;
        
        
    for(int i = 0; i < bemenet.length(); ++i)
    {
        int c = bemenet.charAt(i);
 
        if (c == 0x3e) {			// > karakter
                kommentben = true;
                continue;
            }

        if (c == 0x0a) {			// újsor
            kommentben = false;
            continue;
        }

        if (kommentben) {
            continue;
        }

        if (c == 0x4e) // N betű
        {
            continue;
        }

       
        for (int j = 0; j < 8; ++j) {
           
            if ((c & 0x80) == 128) 
            {
                hozzarendel('1');
            } else 
            {
                hozzarendel('0');
            }
            c <<= 1;
        }

    }
    
    kiir();
    kimenet.append("depth = " + getMelyseg() + "<br>\n");
    kimenet.append("mean = " + getAtlag()+ "<br>\n");
    kimenet.append("var = " + getSzoras() + "<br>\n");

    }

            ]]></programlisting>
            Már nincs szükség a fájlkezeléshez szükséges objektumokra, mivel a 
            kiírás a <function>bemenet</function> bufferbe történik. Az utolsó, és
            egyben legfontosabb függvény pedig a <function>doGet</function>
            függvény, mely a <function>HttpServlet</function> osztály
            egy tagfüggvénye. Ez szolgál arra, hogy GET kérést intézzünk a 
            szerver felé.
            <programlisting language="java"><![CDATA[
public void doGet(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
      
      // Set response content type
      response.setContentType("text/html");
      
    if(request.getParameter("bemenet") == null){
        return;
    }
    else
      CreateStringBuffer(request.getParameter("bemenet"));
    
    PrintWriter out = response.getWriter();
    String title = "LZWBinFa";
    String docType =
         "<!doctype html public \"-//w3c//dtd html 4.0 " + "transitional//en\">\n";
         
    out.println(docType +
         "<html>\n" +
            "<head><title>" + title + "</title></head>\n" +
            "<body>\n" +
               "<h1 align = \"center\">" + title + "</h1>\n" + 
                 kimenet + 
            "</body>" +
         "</html>"
      );
   }
            ]]></programlisting>
            A <function>setContentType</function> függvény segítségével 
            be tudjuk állítani, hogy milyen fomrátumban küldje a szerver a kért
            reprezentációt. Jelen esetben mi ezt egy HTML formátumban kérjük. 
            A hibás működés elkerülése érdekében kezelni kell azt az esetet, ha 
            a felhasználó elfelejti megadni a bemenetet. Ha van bemenetünk, akkor
            a <function>CreateStringBuffer</function> segítségével felépítjük, és
            kiírjuk a fát a bufferbe. A <function>PrintWriter</function> 
            osztály segítségével megírjuk, hogy hogyan nézzen ki a válasz, mit
            tartalmazzon. Lényegében egy klasszikus html fájlt hozunk létre. 
            Ha a fenti paranccsal fordítjuk a forrást, akkor ideális esetben 
            kapunk két <filename>.class</filename> fájlt. Mind a kettőt be kell
            másolni a fentebb megadott helyre, és módosítani kell az xml-fájlt. 
            Mielőtt elkezdenéd bemásolni a class-okat, ellenőrizd, hogy
            le van-e állítva a Tomcat server. Ha nincs, állítsd le, majd a 
            módosítások elvégzése után már csak be kell írni a következőt:
            <programlisting><![CDATA[
                http://localhost:8080/LZWBinFa?bemenet=szöveg
            ]]></programlisting>
            <figure>
                <title>Java servlet</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/LZW/Java_servlet/servlet.png" format="PNG" scale="250"/>
                        </imageobject>
                    </mediaobject>
            </figure>

        </para>
    </section>        
    
    <section>
        <title>Gagyi</title>
        <para>
            Az ismert formális
            <function><![CDATA[„while (x <= t && x >= t && t != x);"]]></function> tesztkérdéstípusra adj a szokásosnál
            (miszerint x, t az egyik esetben az objektum által hordozott érték, a másikban meg az objektum
            referenciája) „mélyebb” választ, írj Java példaprogramot mely egyszer végtelen ciklus, más x, t
            értékekkel meg nem! A példát építsd a JDK Integer.java forrására
            , hogy a 128-nál inkluzív objektum
            példányokat poolozza!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/Gagyi">https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/Gagyi</link>             
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A feladat arra épül, hogy a Java <function>Integer</function> osztálya 
            a 128-nál kisebb egészeket pool-ozza. Ez abban nyilvánul meg, hogy 
            ha példányosítunk egy <function>Integer</function> objektumot, ami 
            128-nál kisebb értéket kap, akkor az objektum referencia ugyanarra a 
            memóriaterületre hivatkozik. Lássuk a forrást:
            <programlisting language="java"><![CDATA[
class Gagyi{
	public static void main (String[] args){
            if (args.length != 2){
                System.out.println("Használat: java Gagyi szám");
                return;
            }
            
            Integer x = Integer.parseInt(args[0]);
            Integer t = Integer.parseInt(args[0]);
                
            while (x >= t && x <= t && x != t){
                System.out.println("Gagyiiii");
            }
	}
} 
            ]]></programlisting>
            A program 1 egész számot kér paraméterként, majd ezek értékét átadjuk
            x és t objektumrefernciáknak. Ezután pedig végrehajtjuk a feladatban megadott
            ciklust. A ciklus ellentmondása abból adódna egy laikusnak, hogy lényegében a 
            feltétel azt vizsgálja, hogy teljesül-e az, hogy <function>x</function> és
            <function>t</function> egyenlő, emellett pedig <function>x</function> és 
            <function>t</function> nem egyenlő. Viszont Java-ban létezik az automatikus 
            csomagolás fogalma. Ennek annyi a lényege, hogy a program autmatikusan 
            kicsomagolja az <function>Integer</function> osztály értékét, abban az 
            esetben, ha ez szükséges. Például a <function><![CDATA[<=, >=]]></function>
            operátorok esetén megtörténik a kicsomagolás. Ellenben a
            <function><![CDATA[!=]]></function> operátor objektum refernciákat
            hasolít össze. Ha a két <function>Integer</function> objektum 
            értéke ugyanaz, és 128-nál kisebb az értéke, akkor nem lépünk be a 
            végtelen ciklusba. Ellenben ha 127-nél nagyobb egészt adunk meg, akkor
            viszont belépünk, amiatt, mert ebben az esetben az objektum referenciák
            különbözőek lesznek.
        </para>
    </section>    
            
    <section>
        <title>Yoda</title>
        <para>
            Írjunk olyan Java programot, ami java.lang.NullPointerEx-el leáll, ha nem követjük a Yoda
            conditions-t! 
        </para>
        <para>
            <link xlink:href="https://en.wikipedia.org/wiki/Yoda_conditions">https://en.wikipedia.org/wiki/Yoda_conditions</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/Yoda">https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/Yoda</link>               
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A Yoda conditions nevét a Star Wars-ból ismert Yoda karakterről kapta. Az
            említett filmben ő angolul beszél, viszont nem a nyekv hagyományos
            szintaxisával. Ilyen furcsaságról van szó itt is. Azért találták ki, hogy
            megkönnyítsék a programozók számára az elírások kiszűrését, abban az esetben, amikor
            egyenlőséget vizsgálunk.
            Főleg akkor
            érdemes használni, amikor a változókat nem változóval hasonlítjuk össze, hanem
            valamilyen konstanssal.
            <programlisting language = "java"><![CDATA[
Integer a = 5;
//Yoda használata nélkül
if (a == 6)
  //valamit csinál 

//Yoda használatával     
if (6 == a)
   //valamit csinál
            ]]></programlisting>
            Ahogy látható a Yoda conditions lényege, hogy felcseréljük a feltételben a 
            változót a konstanssal. Ez a technika megkönnyíti a hibakeresését például 
            ebben az esetben:
            <programlisting language= "java"><![CDATA[
if (6 = a)          if (a = 6)
            ]]></programlisting>
            Ha így írjuk a feltételt, akkor is működni fog a program, de az 
            <function>if</function>-be mindig be fog lépni a vezérlés, mivel 
            annak fejlécében csak értéket adunk át, és nem feltételt vizsgálunk.
            Ezzel az a probléma, hogy a programunk nem megfelelően működik, és
            ez a legrosszabb módja, mert nem is kapunk visszajelzést a hibáról.
            Viszont az első esetben sokkal egyszerűbb észrevenni, mint a 
            másodiknál.
        </para>
        <para>
            Most, hogy tudjuk, mi is az a Yoda conditions, lássuk a feladat 
            megoldását.
            <programlisting language="java"><![CDATA[
class Yoda{
    public static void main (String[] args){
        String a = null;

        if(a.equals("Yoda")){
//        if("Yoda".equals(a)){
            System.out.println("Yoda");
        }
    }
}  
            ]]></programlisting>
            Jelen álllapotában a program kivételt dob, pontosan azt , amit a 
            feladat előír, a java.lang.NullPointerEx-et. Ez annak köszönhető, hogy
            az <function>a</function> objektum refencia <function>null</function>
            értékű, és ennek a tagfüggvényét hívjuk meg. Mivel nem létező 
            objektumra mutat hivatkozik, ezért kapunk hibát. Viszont a 
            kikommentezett feltételt használva már nem kapunk hibát. Ez annak
            köszönhető, hogy a beírt szöveg egyből <function>String</function>-é
            konvertálódik, és el tudjuk érni annak tagfüggvényeit.
            <figure>
                <title>Yoda conditions alkalmazásával</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Yoda/yoda_on.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            <figure>
                <title>Yoda conditions alkalmazása nélül</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Yoda/yoda_off.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Összegezve a láttotakat, kijelenthetjük, hogy bizonyos esetben igazán hasznos lehet
            a Yoda conditions használata. Több órás keresgéléstől kímélhetjük meg magunkat egyes
            hibák felderítése során.
        </para>
    </section>
    
    <section>
        <title>Kódolás from scratch</title>
        <para>
            Induljunk ki ebből a tudományos közleményből: <link xlink:href="http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbpalg.pdf">http://crd-legacy.lbl.gov/~dhbailey/dhbpapers/bbpalg.pdf</link>
            és csak ezt tanulmányozva írjuk meg Java nyelven a BBP algoritmus megvalósítását!
        </para>
        <para>
            Ha megakadsz, de csak végső esetben: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/
            javat-tanitokjavat/apbs02.html#pi_jegyei">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitokjavat/apbs02.html#pi_jegyei</link>
            (mert ha csak lemásolod, akkor pont az a fejlesztői élmény marad ki,
            melyet szeretném, ha átélnél).
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/blob/master/attention_raising/Source/PiBBP_sajat.java">https://github.com/fupn26/BHAX/blob/master/attention_raising/Source/PiBBP_sajat.java</link>               
        </para>
        <para>
           <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A BBP, teljes nevén Bailey-Borwein-Plouffe algoritmus a Pi hexadecimális
            jegyeinek egy d>0 számjegytől történő kiszámolására szolgál. Az alapját
            a BBP formula jelenti, amit 1995-ben találtak ki.
        </para>
        <para>
            Maga az algoritmus a következő:
        </para>
        <para>
            {16<superscript>d</superscript>π} = {4{16<superscript>d</superscript>S1} − 2{16<superscript>d</superscript>S4} − {16<superscript>d</superscript>S5} − {16<superscript>d</superscript>S6}}
        </para>
        <para>
            A feladat ennek az algoritmusnak az implementálása. Lássuk a kódot.
            <programlisting><![CDATA[
class PiBBP{
    //{16^dπ} = {4{16^dS1} − 2{16^dS4} − {16^dS5} − {16^dS6}}
    public double result;
    public String HexaJegyek;
    public PiBBP(int d){
        double d16S1 = dj16s(d,1);
        double d16S2 = dj16s(d,4);
        double d16S3 = dj16s(d,5);
        double d16S4 = dj16s(d, 6);
        
        double temp = 4.0d*d16S1 - 2.0d*d16S2 - d16S3 - d16S4;
        
        result = temp - java.lang.StrictMath.floor(temp);
        
        StringBuffer sb = new StringBuffer();
        
        Character hexaJegyek[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        
        while(result != 0.0d) {
            
            int jegy = (int)StrictMath.floor(16.0d*result);
            
            if(jegy<10)
                sb.append(jegy);
            else
                sb.append(hexaJegyek[jegy-10]);
            
            result = (16.0d*result) - StrictMath.floor(16.0d*result);
        }
        
        HexaJegyek = sb.toString();

        
    }
    
    
    public double dj16s(int d, int j){
        double sum = 0;
        for(int k = 0; k <= d; ++k){
            sum += (double)binmodk(8*k+j, d-k) / (double)(8*k + j);
        }
        sum -= java.lang.StrictMath.floor(sum);
        
//        long iPart = (long) sum;
//        Double fpart = sum -iPart;
        
        System.out.println(sum);
        return sum;
    }
    
    public long binmodk(int k, int d){
        int t = 1;
        long r = 1;
        while(t <= d){
            t *= 2;
        }
        
        while(t < 1){
            if(d >= t){
                r = (16*r) % k;
                d = d-t;
            }
            t = t/2;
            if (t >= 1){
                r = (r*r) % k;
            }
        }
//        System.out.println(r);
        return r;
    }
    
    public static void main(String[] args){
       PiBBP m_pibbp = new PiBBP(10000000);
       System.out.println(m_pibbp.HexaJegyek);
    }
}

            ]]></programlisting>
            Az első fontos függvény a <function>binmodk</function>, mely
            egy bináris algoritmus a modulo k értékének kiszámolásához.
            Ha ez meg van, akkor ki kell számolnunk a 
            a {16<superscript>d</superscript>Sn}-t. Ezt a 
            <function>dj16s</function> számolja ki. Végül pedig a 
            <function>PiBBP</function> osztály konstruktorában
            pedig kiszámoljuk a {16<superscript>d</superscript>π}
            értékét a képlet és a függvények segítségével.
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>                
