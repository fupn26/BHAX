<!DOCTYPE chapter SYSTEM "docbook.dtd">
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Lauda!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Port scan</title>
        <para>
            Mutassunk rá ebben a port szkennelő forrásban a kivételkezelés szerepére!
        </para>
        <para>
            <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#id527287">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#id527287</link>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A kivételkezelésről már többször szóesett ebben a könyvben. A Java nyelvben kiemelt szerepe van a ennek a hibakezelési metódusnak, ugyanis szerves része a nyelvnek.
            Sok esetben a Java VM nem is engedi fordítani a kódot, ha nem kezeljük a lehetséges kivételeket. Ez C++ programozóknak furcsa lehet, mivel ott a teljes szabadságot élvezünk 
            ebben a tekintetben. Most foglaljuk össze, hogy miért is érdemes használni a hibakezelést, és mit is csinál pontosa. 
        </para>
        <para>
            A kivétel a program végrehatása során keletkezik, mely megszakítja azutsaítások végrehajtását.   
            A nem objektumorientált nyelvekben, mint a C, minden gyanús helyen külön kellett
            kezelnünk az egyes kivételeket, mely a egy hibaüzenet kiírásából és a program leállításából állt. Ezzel szemben C++/Java-ban akár egy helyen is kezelhetjük őket. 
            Az alap szintaxisa a objektum orientált nyelvekben a kivételkezelésnek a következő:
            <programlisting language="c++">
                try{
                    ....
                }
                catch(kivétel deklaráció) {
                    ....
                }
                finally{
                    ....
                }
            </programlisting>
            Tehát a vizsgálni kívánt kódrészt egyszerűen behelyezzük egy <function>try</function> blokkba, majd pedig tetszőleges számú <function>catch</function> blokk
            segítségével kezeljük a kivételeket. A <function>finally</function> blokk mindig meghívódik, függetlenül attól, hoyg történt-e kivételdobás vagy sem. Ezért 
            ebben a blokkban tehetünk "rendet" magubk után, például itt zárjuk be a megnyitott fájlokat, amire már nem lesz szükség. 
            Ahhoz, hogy kivételkezléssel tudjunk foglalkozni, ahhoz kellenek kivételek, melyeket a metódusoka <function>throw</function> kulcszsóval teszik meg. 
            Ezután vesszővel elválasztva tudjuk felsorolni a dobható kivételek típusát. A Java nyelv több osztályt biztosít a kivétlek kezeléséhez, melyek mind
            a <classname>Throwable</classname> osztály leszármazottai. De mi is hozhatunk létre saját osztályt ennek érdekében. 
        </para>
        <para>
            Most lássuk a feladatot. A tárgyalni kívánt kódrészlet a következő:
            <programlisting language="java"><![CDATA[
public class KapuSzkenner {

    public static void main(String[] args) {
        
        for(int i=0; i<1024; ++i)
            
            try {
                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");
                
            }
    }
    
}]]>
            </programlisting>
            Ennek a kódrészletnek a futtatását a saját géped vizsgálatán kívül nem javasoljuk, mivel a Port scannelés nem teljesen legális dolog, de szemléltetésnek kiváló. Maga a 
            program annyit csinál, hogy a prancssori argumentumként kapott gép 1024-nél kisebb portjahoz próbál kapcsolódni. Java-ban a 
            kapcsolódás nagyon egyszerű, csak egy <classname>Socket</classname> típusú objektumra van szükségünk. Ennek a konstruktorába meg kell adni az 
            IP-címet és a portot, ahova csatlakozni szeretnénk. Viszont mi történik akkor, ha nem tudunk csatlakozni a megadott porthoz? Ekkor
            a <varname>socket</varname> objektumunk konstruktora <classname>IOException</classname> típusú kivételt dob. Ha tudunk csatlakozni, akkor
            a cél gép adott portján egy szerver folyamat ül, ellenkező esetben pedig nem. Mivel a dobhat kivételt a programunk, ezért azt kezeljük, 
            tehát berakjuk egy <function>try-catch</function> blokkba. Ha a nem dob hibát a csatlakozás során a program, akkor kiírjuk a terminálba, hogy 
            az adott port figyelt, hiba esetén pedig azt, hogy nem figyelt. A kivételkezlés nélkül nem is tudjuk lefordítani a programunkat, ebből jól látszik, amit
            korábban említettem, hogy a kivételek kezelése a Java nyelv szerves része.  
        </para>
    </section>        

    <section>
        <title>AOP</title>
        <para>
            Szőj bele egy átszövő vonatkozást az első védési programod Java átiratába! (Sztenderd védési
            feladat volt korábban.)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/LZW/AspectJ">https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/LZW/AspectJ</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a feladatban az átszövés orientált programozással fogunk megismerkedni, melyhez az AspectJ programozási nyelvet fogjuk használni. Az átszövés lényegében annyit tesz,
            hogy a régebbi programunk működését úgy tudjuk módosítani, hogy nem kell módosítani a forráskódon. Helyette írunk egy szövést (aspect-et), mellyel megváltoztathatjuk például egy
            függvény működését, vagy esetleg megadhatjuk, hogy a függvény végrehajtása előtt/után mit csináljon a program. Példák ebben a diasorban találhatóak: <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_6.ppt">https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_6.ppt</link>.
            Mi most az AspectJ nyelv <function>around</function> függvényével fogunk foglalkozni, melynek utasításait egy adott függvény helyett hajtjuk végre.
        </para>
        <para>
            Mielőtt megnéznénk a kódot, előtte térjünk ki egy kicsit az aspektusok felépítésére. Tehát van a már korábbi fejezetben megírt <filename>LZWBinFa.java</filename> forrásunk,
            és ennek a függvényét szeretnénk módosítani. Az aspektusok önállóan nem használhatóak, mindig kell egy program hozzá, AspectJ esetén Java. Majd létrehozunk egy aspektust, mely 
            olyan, mint egy normál Java osztály. Össezsségében 3 fogalommal kell megismerkedni ezzel kapcsolatban. Az első a <emphasis role="strong">kapcsolódási pont</emphasis>, mely 
            az eredeti programban van, vagyis az erdeti program egyik függvénye. A másik fontos fogalom az <emphasis role="strong">vágási pont</emphasis>, mely az aspektus része, és 
            a csatlakozási pontokat tudjuk jelöljük vele. Végezetül pedig szükség van még <emphasis role="strong">tanácsra</emphasis>, mely lényegében azt tartalmazza, hogy 
            hogyna szeretnénk módosítani az eredeti program működését. 
        </para>
        <para>
            Most azt nézzük meg, hogyan lehet megoldani azt, hogy a programunk a fát preorder módon járja be. Ezt már korábbi feladatokban megcsináltuk, viszont a akkor a forráskódot
            közvetlenül módosítottuk. Lássuk is az <filename>Aspect.aj</filename> fájl tartalmát.
            <programlisting language="java"><![CDATA[
privileged aspect Aspect{
    void around(LZWBinFa fa, LZWBinFa.Csomopont elem, java.io.BufferedWriter os):
        call(public void LZWBinFa.kiir(LZWBinFa.Csomopont, java.io.BufferedWriter)) 
            && target(fa) && args(elem, os){
        if (elem != null)
        {
            try{
                ++fa.melyseg;
                for (int i = 0; i < fa.melyseg; ++i)
                    os.write("---");
                os.write(elem.getBetu () + "(" + (fa.melyseg - 1) + ")\n");
                fa.kiir(elem.egyesGyermek (), os);
                fa.kiir(elem.nullasGyermek (), os);
                --fa.melyseg;
            }
            catch(java.io.IOException e){
                System.out.println("Csomópont írása nem sikerült.");
            }
        }

    }
}]]>
            </programlisting>
            Láthatjuk, hogy szintaktikailag alig van különbség egy sima Java forráshoz képest. Az első kulcszsó, amit eddig nem láttunk, az a <function>privilaged</function>, melyre
            azért van szükség, hogy az aspektusunk hozzá tudjon férni az osztályok privát tagjaihoz. Az <function>aspect</function> kulcszsó jelöli, hogy most aspektust írunk, nem
            pedig hagyomásnyos osztályt. Az aspektusunk egyetlen függvényből áll, ez a <function>around</function>. Ahhoz, hogy a bejárás módját módosítani tudjuk elsőnek 
            a <function>kiir(Csomopont, BufferedWriter)</function> függvényre vany szükségünk. Mivel ez a függvény olyan tagváltozókat és tagfüggvényeket tartalmaz, melyek nem statikusak, ezért 
            az <function>around</function> függvény paraméterének meg kell adnunk egy <classname>LZWBinFa</classname> objektumot, melyen keresztül ezeket a tagokat el tudjuk érni. 
            Majd megadjuk, hogy az <function>around</function> melyik függvény helyett hívódjon meg, ehhez meg kell adnunk a teljes paraméterlistáját, mivel enélkül a fordító nem tudná
            egyértelműen azonosítani, melyikre gondolunk. Ezután <![CDATA[&&]]> elválasztva megadjuk, hogy az <function>around</function> paraméterei közül melyiket szeretnénk paraméterként
            átadni a <function>kiir</function> függvénynek, és azt is, hogy melyik <classname>LZWBinFa</classname> objektumra szeretnénk végrehajtani a függvényt. Az előbbihez a 
            <function>args</function>, utóbbihoz a <function>target</function> kulcsszót használjuk. Ezután következik a <function>around</function> függvény törzse, mely 
            a már ismert kódrészletet tartalmazza.
        </para>
        <caution>
            <title>Program futtatása</title>
            <para>
                <programlisting language="bash">
sudo apt install aspectj
ajc LZWBinFa.java Aspect.aj
java -cp /usr/share/java/aspectjrt.jar:. LZWBinFa input.txt -o output.txt
                </programlisting>
            </para>
        </caution>
        <para>
            A alap programunk a következő kimenetet adja a <filename>input.txt</filename>-ben található szövegre:
            <programlisting>
---------1(2)
------------0(3)
------------------1(5)
---------------0(4)
------1(1)
---------0(2)
------------0(3)
---------------0(4)
---/(0)
---------1(2)
------0(1)
---------0(2)
------------0(3)
depth = 5
mean = 3.5
var = 1.2909944487358056
            </programlisting>
            Aspektus használatával pedig a követkkező:
            <programlisting>
---/(0)
------1(1)
---------1(2)
------------0(3)
---------------0(4)
------------------1(5)
---------0(2)
------------0(3)
---------------0(4)
------0(1)
---------1(2)
---------0(2)
------------0(3)
depth = 5
mean = 3.5
var = 1.2909944487358056
            </programlisting>
            Az aspektusok használatával a mindig a nekünk szükséges bejárási módot tudjuk használni. Összegezve, az aspektusok legnagyobb előnye, hogy nem szükséges komolyabban 
            belenyúlnunk a régi kódunkba, ahhoz, hogy módosítsunk a működésén. 
        </para>
    </section>        
        
    <section>
        <title>
            <emphasis role="cadiumgreen">Android Játék</emphasis>
        </title>
        <para>
            Írjunk egy egyszerű Androidos „játékot”! Építkezzünk például a 2. hét „Helló, Android!” feladatára!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <caution>
            <title>A feladat megoldásának alapjául ez a vidoeósorozat szolgált:</title>
            <para>
                <link xlink:href=""></link>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a fejezetben egy Snake játékot fogunk elkészíteni Android-ra. A feljlesztéshez az Android Studio-t fogjuk használni. 
        </para>
        <para>
            Első lépésben szükségünk van egy játék motorra, ami kezeli majd a kígyó mozgását, növekedését, és a játék állapotát.
            Lássuk a <filename>GameEngine.java</filename> fontosabb részeit.
            <programlisting language="java">
public void initGame(){
    AddSnake();
    AddWalls();
    AddApples();
}
            </programlisting>
            A játék inicializásásért a <function>initGame</function> felel, mely a kígyó, a falak és az almák pozicióját meghatározó függvényeket hívja meg.
            Mielőtt megnéznénk, hogy ezek mit tartatlmaznak, fontos megjegyezni, hogy a képernyőt egy 42x29 rácsra osztjuk fel, és minden rácsról tároljuk, hogy
            mit tartalamaz. Ehhez hoztuk létre a <classname>TileType</classname> enum osztályt.
            <programlisting language="java">
public enum TileType {
    Nothing,
    Wall,
    SnakeHead,
    SnakeTail,
    Apple
}
            </programlisting>
            Hogy a létrehozott rácsban könnyebb legyen a koordinátákat megadni, ezért készítünk egy <classname>Coordinate</classname> osztályt, melyben 
            tagváltozóként tároljuk az x,y értékeket.
            <programlisting language="java"><![CDATA[
public class Coordinate {
    private int x;
    private int y;

    public Coordinate(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Coordinate that = (Coordinate) o;
        return x == that.x &&
                y == that.y;
    }
}]]>                
            </programlisting>
            Ahhoz, hogy a <classname>Coordinate</classname> típusú objektumokat összetudjuk hasonlítani, ezért implementáljuk a 
            <function>equals</function> függvényt, mely a akkor ad igaz értéket, hogyha a két objektumnak ugyanazok az x és y koordinátái.
            Mostmár visszatérhetünk a játékmotorhoz. Első lépsében a kígyó helyét határozzuk meg a rácsban a <function>AddSnake</function>
            függvény segítségével.
            <programlisting language="java"><![CDATA[
private void AddSnake() {
    snake.clear();

    snake.add(new Coordinate(7,7));
    snake.add(new Coordinate(6,7));
    snake.add(new Coordinate(5,7));
    snake.add(new Coordinate(4,7));
    snake.add(new Coordinate(3,7));
    snake.add(new Coordinate(2,7));

}]]>          
            </programlisting>
            Látható, hogy a koordinátákat egy tömben tároljuk, és ugyanezt alkalmazzuk mind a  falak, mind az almák koordinátája esetén. Lássuk, hogy 
            hogy utóbbiakat, hogyan inicializáljuk.
            <programlisting><![CDATA[
private void AddWalls() {
    for (int i = 0; i < GameWidth; i++) {
        walls.add(new Coordinate(i,0));
        walls.add(new Coordinate(i, GameHeight - 1));
    }

    for (int i = 1; i < GameHeight; i++) {
        walls.add(new Coordinate(0, i));
        walls.add(new Coordinate(GameWidth-1, i));
    }
}]]>          
            </programlisting>
            A falak elhelyezése már érdekesebb. A célünk az, hogy a rácsháló szélén lévő négyzetekben helyezzük el a fal részeit. Ehhez első
            lépésként elkészítjük az alsó és a felső határhoz tartozó koordinátákat, majd a szélsőket is. A szélsők elkészítésénél két-két 
            rácsot ki hagyunk, ugyanis azt már az első <function>for</function> ciklusban hozzáadtunk a tömböhöz. Ha ezzel megvagyunk, akkor
            már csak az almákat kell elhelyezni. Mivel a klasszikus Snake játékban az almák véletlenszerűen jelennek meg, ezért 
            radnom számokkal fogjuk megoldni az alma elhelyezését.
            <programlisting language="java"><![CDATA[
private void AddApples() {
    Coordinate coordinate = null;

    boolean added = false;

    while ( !added ){
        int x = 1 + random.nextInt(GameWidth - 2);
        int y = 1 + random.nextInt(GameHeight -2);

        coordinate = new Coordinate(x,y);
        boolean collision = false;

        for (Coordinate s : snake) {
            if(s.equals(coordinate)){
                collision = true;
                break;
            }
        }
        if(collision) continue;

        for (Coordinate s : apples) {
            if(apples.equals(coordinate)){
                collision = true;
                break;
            }
        }

        added = !collision;

    }

    apples.add(coordinate);
}]]>           
            </programlisting>
            A random szám generálást már több feladatban is láthattuk, szóval annak megvalósítását nem részletezzük. Amire figyelni, hogy nem szabad
            teljesen rábízni magunkat a generátorra, ugyanis ekkor lehet, hogy pont a kígyóra dobjuk rá az új almát. Emiatt mindig ellenőriznünk kell, hogy
            az adott koordinátán nincs-e kígyó. Ha ez nem fordul elő, akkor hozzáadjuk a <varname>apples</varname> tömbhöz az új alma koordinátáit.
        </para>
        <para>
            Tehát a motorunk képes feltölteni a rácshálót a szükséges elemekkel. Már csak arra lenne szükség, hogy a képes éegyen frissíteni is a 
            háló állapotát. Erre a célra szolgál a <function>Update</function> függvény.
            <programlisting language="java"><![CDATA[
public void Update (){
    switch (currentDirection){

        case North:
            UpdateSnake(0, -1);
            break;
        case East:
            UpdateSnake(1,0);
            break;
        case South:
            UpdateSnake(0,1);
            break;
        case West:
            UpdateSnake(-1, 0);
            break;
    }

    for(Coordinate w : walls){
        if(snake.get(0).equals(w)){
            currentGameState = GameState.Lost;
        }
    }

    for (int i = 1; i < snake.size(); ++i) {
        if(getSnakeHead().equals(snake.get(i))){
            currentGameState = GameState.Lost;
            return;
        }
    }

    Coordinate appleToRemove = null;
    for ( Coordinate apple : apples ){
        if(getSnakeHead().equals(apple)){
            appleToRemove = apple;
            increaseTail = true;
        }
    }

    if(appleToRemove != null) {
        apples.remove(appleToRemove);
        AddApples();
    }
}]]>
            </programlisting>
            Az aktuális menetirányt a <varname>currentDirection</varname> változóban tároljuk, mely egy <classname>Direction</classname> típusú objektum.
            <programlisting language="java">
public enum Direction {
    North,
    East,
    South,
    West
}
            </programlisting>
            A frissítés során elsőnek tehát meg kell határoznunk, hogy merre megy a kígyó, ennek függvényében frissítjük a <varname>snake</varname>
            tömböt. Ehhez pedig a <function>updateSnake</function> függvényt használjuk.
            <programlisting language="java"><![CDATA[
private void UpdateSnake(int x, int y){
    int newX = snake.get(snake.size() - 1).getX();
    int newY = snake.get(snake.size() - 1).getY();

    for (int i = snake.size() - 1; i > 0 ; i--) {
        snake.get(i).setX(snake.get(i-1).getX());
        snake.get(i).setY(snake.get(i-1).getY());
    }

    if(increaseTail){
        snake.add(new Coordinate(newX, newY));
        increaseTail = false;
    }

    snake.get(0).setX(snake.get(0).getX() + x);
    snake.get(0).setY(snake.get(0).getY() + y);
}]]>            
            </programlisting>
            Ez a függvény kezeli a kígyó irányváltását, mozgását, és a növekedését is. Mivel mozgatjuk a kígyót, ezért lényegében annyit csinálunk, hogy a 
            eggyel toljuk a kígyó részeihez tartozó elemek koordinátáit. Vagyis ami az fejhez tartozott, az most a második elemhez fog tartozni, és így tovább.
            Ha a kígyó megevett egy almát, akkor pedig bővítjük a <varname>snake</varname> tömböt. Ez nagyon egyszerű múvelet, ugyanis elég mindig az 
            utolsó elem koordinátáját megtudni, és oda berakni az újat. Ez annak kösz9nhető, hogy amikor bővítünk, akkor már az elemek eltolódtak. Jogosan merül
            fel a kérdés, hogy ez így nagyon jól hangzik, de mi lesz a fejjel. Hiszen a fej előtt már nincs több elem, aminek a koordinátáit lekérdezhetnénk.
            Emiatt kezeljük külön a kígyó feját, mely az aktuáls irány alapján változik. 
        </para>
        <para>
            Térjünk vissza az <function>Update</function> függvényre. Az irány meghatározása után azt kell ellenőriznünk, hogy a kígyó feje 
            ütközik-e a saját testével, vagy a fallal. Ezekben az esetkben uyganis a játék véget ér. Ahhoz, hogy az állapotokat könnyen tudjuk kezelni, 
            egy újabb enum osztályt vezetünk be, a <classname>GameState</classname>-et.
            <programlisting language="java"><![CDATA[
                public enum GameState {
                    Ready,
                    Running,
                    Lost
                }]]>
            </programlisting>
            Ha pedig a kígyó feje egy almával ütközik, akkor pedig növeljük az kígyó hosszát, ahogy már az <function>UpdateSnake</function> függvényben láthattuk.
            Ezután pedig  egy új almát jelenítünk meg a képernyőn.
        </para>
        <para>
            Lassan már mindent tud a játékmotor, amire szükségünk van. Azt kéne még megoldni, hogy az egyes rácspontok "állapotát" tartalmazó
            tömböt át tudja adni majd a megjelenítésért felelős osztályunknak.
            <programlisting language="java"><![CDATA[
public TileType[][] getMap  (){
    TileType[][] map = new TileType[GameWidth][GameHeight];

    for (int i = 0; i < GameWidth; i++) {
        for (int j = 0; j < GameHeight; j++) {
            map[i][j] = TileType.Nothing;
        }

    }

    for(Coordinate s : snake){
        map[s.getX()][s.getY()] = TileType.SnakeTail;
    }

    map[snake.get(0).getX()][snake.get(0).getY()] = TileType.SnakeHead;


    for (Coordinate a : apples) {
        map[a.getX()][a.getY()] = TileType.Apple;
    }

    for (Coordinate wall: walls) {
        map[wall.getX()][wall.getY()] = TileType.Wall;
    }
    return map;
    }]]>           
            </programlisting>
            Eddig még nem tároltuk az egyes rácsok állapotát, csak koordinátákat adtunk hozzá a játékot felépítő elemek tömbjeihez. A <function>getMap</function>
            függvény definiál egy <classname>TileType</classname> kétdimenziós tömböt. Ezt elsőnek feltöltjük csupa üres állapottal. Majd a végig megyünk egy 
            <function>for</function> ciklussal a <varname>snake</varname>, <varname>apples</varname>, <varname>walls</varname> tömbökön, és beállítjuk a 
            megfelelő állapotokat. A kígyó feje itt is külön szerepel, ugyanis az a megjelenítés során is el fog különülni a kígyó farkától.
            Ezzel a végére értünk a játékmotor készítésnek. 
        </para>
        <para>
            A következő lépés, hogy a <classname>GameEngine</classname> osztályunk által biztosított <varname>map</varname>-ot megjelenítsük. Erre szolgál a 
            <classname>SnakeView</classname> osztályunk, mely a <classname>View</classname> osztály gyermeke. A <classname>View</classname> egy Android-os 
            osztály, mely segítségével a képernyőre tudunk rajzolni. Lássuk a <classname>SnakeView</classname> osztály forrását.
            Androidon 4 fontos elemre van szükségünk, hoyg rajzoli tudjunk. Az első az, amire rajzolunk, ez jelen esetben egy <classname>SnakeView</classname>
            objektum. Szükség van egy <classname>Canvas</classname> objektumra, mely a rajzolást végzi. Ennek meg kell határoznunk, hogy mit szeretnénk rajzolni,
            és, hogy milyen színnel. Utóbbi miatt szükség van még egy <classname>Paint</classname> típusú objektumra.
            <programlisting language="java"><![CDATA[
public class SnakeView extends View {
    private Paint m_Paint = new Paint();
    private TileType snakeViewMap[][];

    public SnakeView(Context context) {
        super(context);
    }

    public SnakeView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    public SnakeView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public SnakeView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    public void setSnakeViewMap(TileType[][] map){
        this.snakeViewMap = map;
    }

    @Override
    protected void onDraw(Canvas canvas){
        super.onDraw(canvas);

        if (snakeViewMap != null){
            float tileSizeX = canvas.getWidth() / snakeViewMap.length;
            float tileSizeY = canvas.getHeight() / snakeViewMap[0].length;

            float circleSize = Math.min(tileSizeX, tileSizeY) / 2;

            for (int x = 0; x < snakeViewMap.length; ++x){
                for (int y = 0; y < snakeViewMap[x].length; ++y){
//                    if(snakeViewMap[x][y] != null) {
                        switch (snakeViewMap[x][y]) {

                            case Nothing:
                                m_Paint.setColor(Color.WHITE);
                                break;
                            case Wall:
                                m_Paint.setColor(Color.BLACK);
                                break;
                            case SnakeHead:
                                m_Paint.setColor(Color.RED);
                                break;
                            case SnakeTail:
                                m_Paint.setColor(Color.YELLOW);
                                break;
                            case Apple:
                                m_Paint.setColor(Color.GREEN);
                                break;
                        }
//                      }
                    canvas.drawCircle(x * tileSizeX + tileSizeX / 2f + circleSize / 2, y * tileSizeY + tileSizeY / 2f + circleSize / 2, circleSize, m_Paint);
                }
            }
        }
    }
}]]>
            </programlisting>
            A fentieknek megfelelően szükségünk van egy <classname>Paint</classname> típusú objektumra, ez lesz az <varname>m_Paint</varname>. A konstruktorokra figyleni kell, ugyanis 
            ha nem a megfelelő verzióját implementáljuk, akkor hibát kaphatunk. Ez amiatt van, mert Androidon <classname>Viwe</classname> típusú osztályok az xml fájlon keresztül
            lesznek példányosítva, mely meghív egy megfelelő konstruktort, de előfordulhat, hoyg az éppen nincs implementálva. A mi megoldásunkban az összes
            konstruktor implementálva lett, garantálva ezzel a biztos működést. A <varname>map</varname>-ot a motortól majd a <function>setSnakeViewMap</function>
            függvényen keresztül fogjuk megkapni. Végezetül jöjjön a legfontosabb része a <classname>SnakeView</classname> osztályunknak, az <function>onDraw</function>
            függvény. A függvényünk lényegében annyit tesz, hogy a rácsok 
            típusa alapján átállítja az <varname>m_Paint</varname> objektumunk színét, majd rajzol <classname>Canvas</classname> segítségével egy kört az adott 
            színnel, az adott rácspontba.
        </para>
        <para>
            Végül pedig elékeztünk a fő osztályunkhoz, a <classname>MainActivity</classname>-hez. Most nézzük végig ennek az osztálynak a fontosabb részeit.
            <programlisting language="java"><![CDATA[
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_starting);

    Button start = findViewById(R.id.startbutton);
    Button quit = findViewById(R.id.quitbutton);

    start.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            setContentView(R.layout.activity_main);
            gameEngine = new GameEngine();
            gameEngine.initGame();

            snakeView = (SnakeView)findViewById(R.id.snakeView);
            CreateTouchListener();

            startUpdateHandler();

        }
    });
    
    quit.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            finish();
            System.exit(0);
        }
    });
}
]]>            
            </programlisting>
            Az <function>onCreate</function> függvény akkot hívódik meg, amikor megnyitjuk az alkalmazást. A <function>setContentView</function> függvény
            segítségével tudjuk megadni melyik megjelenítési réteget szeretnénk használni. A rétegetket xml fájlokban kell megadni Android-on. Ebből
            nekünk 3 van, az egyik a kezdőképernyő, a majd jön, ami tartalmazza a <classname>SnakeView</classname> osztályunk egy példányát, végül pedig a 
            vereség esetén használt képernyő. Ezeket tudjuk váltogatni, akárhányszor csak szeretnénk. Tehát elsőnek a <filename>acrivity_starting.xml</filename>
            fájlt adjuk meg rétegnek. Ez tartalmaz két gombot, egy indítót, és egy bezárót. Ezek refernciáját az xml fájlban megadott ID-jük alapján érjük el. 
            Ezután egy <classname>onClickListener</classname> osztály <function>onClick</function> függvényére, mely utasításokat hajt végre, ha valamelyik gombot megnyomjuk. A használni kívánt
            <classname>onClickListener</classname> objektumot a <function>setOnClickListener</function> függvény segítségével adhatjuk meg. A <varname>start</varname>
            gomb esetén átállunk a <classname>SnakeView</classname> típusú objektumunkat tartalmazó <filename>activity_main.xml</filename> rétegre. Majd 
            példányosítunk egy <classname>GameEngine</classname> objektumot, és meghívjuk az <function>initGame</function> tagfüggvényét. Majd lekérjük a 
            <varname>snakeView</varname> objektumunk refernciáját. Ahhoz, hogy a kígyót tudjuk mozgatni, be kell állítanunk a használni kívánt 
            <classname>onTouchListener</classname> típusú objektumot. Mivel a <classname>MainActivity</classname> osztály implementálja ezt az interfészt, ezért
            önmagát adjuk meg a <function>snakeView</function> objektumnak.
            <programlisting language="java"><![CDATA[
private void CreateTouchListener() {
    snakeView.setOnTouchListener(this);
}]]>            
            </programlisting>
            Ahhoz, hogy a Androidon bizonyos időközönként hajtsunk végre egy utasítást, ahhoz a <classname>Handler</classname> osztályt használjuk.
            A <function>startUpdateHandler</function> függvény segítségével a <varname>handler</varname> objektumunknak adjuk meg, hogy milyen utasításokat
            hajtson végre, a <varname>delay</varname> változóban megadott időközönként.
            <programlisting language="java"><![CDATA[
private void startUpdateHandler(){
    m_Runnable = new Runnable() {
        @Override
        public void run() {
            gameEngine.Update();

            if (gameEngine.getCurrentState() == GameState.Running){
                handler.postDelayed(this, updateDelay);
            }
            if (gameEngine.getCurrentState() == GameState.Lost) {
                OnGameLost();
            }

            snakeView.setSnakeViewMap(gameEngine.getMap());
            snakeView.invalidate();
        }
    };
    handler.postDelayed(m_Runnable,updateDelay);
}]]>           
            </programlisting>
            Elsőnek szükség van egy <classname>Runnnable</classname> objektumra. Ennek a <function>run</function> metódusát definiáljuk, melyben meghívjuk a 
            motorunk <function>Update()</function> tagfüggvényét, lekérjük az aktuális rácsháló állapotot, és átadjuk a <varname>snakeView</varname> objektumnak,
            majd a <function>invalidate</function> függvénnyel elérjük, hogy a <varname>snakeView</varname> újra rajzolja önmagát. Ahhoz, hogy ezt a 
            a <varname>handler</varname> elvégezze a megaddott késleltetéssel, meg kell hívnunk a <function>postDelayed</function> metódusét, mely egy 
            <classname>Runnable</classname> objektumot, és egy <classname>int</classname>-et kér paraméteréül. Ha már a játék véget ért, akkor hívódik meg a 
            <function>OnGameLost</function> függvény.
            <programlisting><![CDATA[
private void OnGameLost() {
    Toast.makeText(this, "Game Over", Toast.LENGTH_SHORT).show();
    setContentView(R.layout.activity_gameover);

    Button retry = findViewById(R.id.retrybutton);
    Button quit = findViewById(R.id.quitbutton_2);

    retry.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            setContentView(R.layout.activity_main);
            gameEngine = new GameEngine();
            gameEngine.initGame();

            snakeView = (SnakeView)findViewById(R.id.snakeView);
            CreateTouchListener();

            startUpdateHandler();

        }
    });

    quit.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            finish();
            System.exit(0);
        }
    });

}]]>            
            </programlisting> 
            Ez a függvény leváltja az aktuális réteget a <filename>activity_gameover.xml</filename>-re. Itt a már megszokott dolgot hatjuk végre, van két gomb,
            a <varname>retry</varname> és a <varname>quit</varname>. Ha az előbbit nyomjuk meg, akkor újraindítjuk a játékot, míg utóbbi esetében kilépünk a 
            programból.
        </para>
        <para>
            Mivel implementáltuk a <classname>onTouchListener</classname> interfészt, emiatt implemetálnunk kell az <function>onTouch</function>
            metódust.
            <programlisting language="java"><![CDATA[
@Override
public boolean onTouch(View v, MotionEvent event) {
    switch(event.getAction()){
        case MotionEvent.ACTION_DOWN:
            prevX = event.getX();
            prevY = event.getY();

            break;
        case MotionEvent.ACTION_UP:
            float newX = event.getX();
            float newY = event.getY();


            if(Math.abs(newX - prevX) > Math.abs(newY - prevY)){
                if ( newX > prevX){
                    //RIGHT
                    gameEngine.UpdateDirection(Direction.East);
                } else {
                    //LEFT
                    gameEngine.UpdateDirection(Direction.West);
                }
            }else{
                if (newY > prevY){
                    //UP
                    gameEngine.UpdateDirection(Direction.South);
                } else {
                    //DOWN
                    gameEngine.UpdateDirection(Direction.North);
                }
            }
            break;
    }

    return true;
}]]>
            </programlisting>
            Ezzel azt valósítjuk meg, hogy a kígyó annak függvényében, hogy merre húzzuk az ujjunkat. 
        </para>
        <para>
            Egy fontos dolog van még, ami zavaró lehet, ha nem oldjuk meg. Jelen esetben nem kezeljük azt, hogy mi történjen, ha az alkalmazást szüneteltetjük.
            Tehát a kígyó akkor is tovább mozog, és nem tudjuk ott folytatni, ahol abba haygtuk. Emiatt 2 függvényt még definiálnunk kell, az
            <function>onPause</function> és <function>onResume</function>-ot.
            Előbbi azért felel, hogy a felesleges erőforrásokat felszabadítsuk a szünet alatt, utóbbi pedig a újra inicializálja azokat.
            <programlisting language="java"><![CDATA[
@Override
protected void onPause() {
    super.onPause();
    handler.removeCallbacks(m_Runnable);
}]]>            
            </programlisting> 
            A probléma megoldásához nekünk csak annyi kell, hogy el kell távolítanunk a <varname>m_Runnable</varname> objektumunkat a 
            végrehajtandó postok közül.
            <programlisting language="java"><![CDATA[
@Override
protected void onResume() {
    super.onResume();
    handler.postDelayed(m_Runnable, updateDelay);
}]]>
            </programlisting>
            Ha pedig visszatérünk a játékhoz, akkor újra végrehajtatjuk az <varname>m_Runnable</varname> objektumot a <varname>handler</varname>-rel. 
        </para>
        <para>
            Ezzel az utolsó javításokat is elvégeztük a programban. Lássuk, hogyan néz ki működés közben.
            <figure>
                <title>Android Snake</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/AndroidSnake/program.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
        </para>
    </section>
    <section>
        <title>JUnit teszt</title>
        <para>
            A <link xlink:href="https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat">https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat</link>
            poszt kézzel számított mélységét és szórását dolgozd be egy Junit tesztbe (sztenderd védési feladat
            volt korábban).
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/LZW/LZWBinFaJunit">https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/LZW/LZWBinFaJunit</link>              
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A JUnit egy a Java nyelvhez kifejleszettet egységtesztelő keretrendszer. Segítségével automatizált módon tudjuk tesztelni, hogy a programunk a várt módon működik-e. 
            Mi ebben a feladatban azt fogjuk letesztelni, hogy a mélység, a szórás és az átlag értékek megfelelnek-e annak, amit korábban egy posztban már láthattunk. A 
            NetBeans-ben létre kell hoznunk egy projektet, amibe belerakjuk a <classname>LZWBinFa</classname> osztály forrását, majd ha erre rákattintunk a 
            Tools menüpontban létrehozunk egy tesztet.
            <figure>
                <title>Teszt létrehozása</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/LZW/LZWBinFaJunit/create_test.png" format="PNG" scale="50"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Célszerű csak a képen látható opciókat kipipálni a létrehozás során. Ha elkészítettük a tesztet, akkor a "Test Libraries"-hoz hozzás kell adni a Junit 4.x könyvtárát. Majd nyissuk 
            meg újra a projektet. Ekkor a Netbeans hibát fog írni, de hagyjuk rá a megoldást. Ezután pedig a forrásunkra kattintva jobb egér gombbal lesz egy olyan opció, hogy 
            "Test file". Ha mindent jól csináltunk, akkor lefut a teszt hiba nélkül.
        </para>
        <para>
            Nézzük meg a teszthez tartozó forrást.
            <programlisting language="java"><![CDATA[
import static junit.framework.TestCase.assertEquals;
import org.junit.Test;

public class LZWBinFaTest {
    LZWBinFa binfa = new LZWBinFa();
    
    @Test
    public void testHozzarendel() {
        char[] minta = "01111001001001000111".toCharArray();
        
        for(char betu: minta ){
            binfa.hozzarendel(betu);
        }
        
        assertEquals(4, binfa.getMelyseg());
        assertEquals(2.75, binfa.getAtlag(), 0.01);
        assertEquals(0.957427, binfa.getSzoras(), 0.000001);
    }    
    
}]]>           
            </programlisting>
            Szintaktikailag egy normál Java osztályt látunk. A különlegességét az adja, hogy tartalmazza a <![CDATA[@Test]]> makrót, melyel jelöljük, hogy ezután 
            egy tesztelő függvényt definiálunk. Az <classname>LZWBinFaTest</classname> osztályban példányosítunk egy <classname>LZWBinFa</classname> típusú objektumot. 
            Majd a <function>testHozzarendel</function> függvény segítségével teszteljük, hogy a <function>hozzarendel</function> függvény megfelelőeb építi-e fel a fát.
            A <varname>minta</varname> tömbben eltároljuk a honlapon található mintát, majd maszkolás nélkül belerakjuk az 1-eseket és a 0-ákat a fába. Ha ezzel végeztünk, 
            akkor a <function>assertEquals</function> függvény segítségével ellenőrizzük, hogy azokat a szórás, mélység és átlag értékeket kaptuk, amire számítottunk. 
            A forrásban ennek a függvénynek 2 verzióját használtuk. Az első esetben sima összehasonlítást végzünk, a többi esetben pedig megadunk egy delta számot, amivel 
            eltérhet a várt érték a kapott értéktől. Erre azért van szükség, mert nem egész számokat hasonlítunk össze, és ebben az esetben így kell eljárni. Sőt 
            igazából, akkor minden programban, ahol <type>double/float</type> típusú változókat hasonlítunk, ott szükség mindeig meg kéne adni egy tetszőlegesen kicsi 
            delta számot, aminél ha kisebb az eltérés a két szám között, akkor egyenlőnek tartjuk őket.
            <figure>
                <title>Eredmény</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/LZW/LZWBinFaJunit/result.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>   
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    <section>
        <title>
            OSCI
        </title>
        <para>
            Készíts egyszerű C++/OpenGL-es megjelenítőt, amiben egy kocsit irányítasz az úton. 
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        


    <section>
        <title>
            <emphasis role="blue">OSCI2</emphasis>
        </title>
        <para>
            Készíts egyszerű C++/OpenGL-es megjelenítőt, amiben egy kocsit irányítasz az úton. A kocsi
            állapotát minden pillanatban mentsd le. Ezeket add át egy Prolog programnak, ami egyszerű reflex
            ágensként adjon vezérlést a kocsinak, hasonlítsd össze a kézi és a Prolog-os vezérlést. Módosítsd
            úgy a programodat, hogy ne csak kézzel lehessen vezérelni a kocsit, hanem a Prolog reflex ágens
            vezérelje!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>
    
    <section>
        <title>
            <emphasis role="blue">OSCI3</emphasis>
        </title>
        <para>
            Készíts egy OSM utakat megjelenítő C++/OpenGL-es progit!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        
       

</chapter>                
