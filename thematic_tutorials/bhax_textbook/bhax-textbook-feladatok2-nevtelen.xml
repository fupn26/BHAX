<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló,...!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
            Javítsunk valamit a ActivityEditor.java JavaFX programon!
            <link xlink:href="https://github.com/nbatfai/future/tree/master/cs/F6">https://github.com/nbatfai/future/tree/master/cs/F6</link>
        </para>
        <para>
            Itt láthatjuk működésben az alapot: <link xlink:href="https://www.twitch.tv/videos/222879467">https://www.twitch.tv/videos/222879467</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">JavaFx beizzítása NetBeans-ben</emphasis>
        </para>
        <para>
                Ez a leírás azért szükséges, mert a JavaFx már nem része a Java JDK-nak. Én a programomhoz a Java JDK 11-et és a JavaFX 11-et használtam.
                <orderedlist>
                    <listitem>
                        <para>Elsőnek töltsd le a JavaFX SDK-t a következő oldalról:<link xlink:href="https://gluonhq.com/products/javafx/">https://gluonhq.com/products/javafx/</link></para>
                    </listitem>
                    <listitem>
                        <para>
                            Következő lépés, hogy a JavaFX <filename>*.jar</filename> fájljait láthatóvá tesszük a NetBeans számára.
                            Ehhez a <emphasis role="strong"><![CDATA[Tools -> Libraries]]></emphasis> menüpontba kell navigálni. Ahol
                            létre kell hozni egy új könyvtárat, és hozzáadni a <filename>*.jar</filename> fájlokat.
                            <figure>
                                    <title>JavaFX könyvtár létrehozása</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/createlibrary.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Létrehozunk egy új ANT projektet (simát, nem JavaFX-eset), majd a projekten belül a <emphasis role="strong"><![CDATA[Libraries]]></emphasis>-ra kattintva jobb egérgombbal a 
                            <emphasis role="strong"><![CDATA[Add Library]]></emphasis> lépéseket
                            követve hozzáadjuk a korábban létrehozott könyvtárat.
                            <figure>
                                    <title>JavaFX könyvtár hozzáadása a projekthez</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/addlibrary.png" format="PNG" scale="90"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Most, ha futtatod a programod, hibát fogsz kapni.
                            <programlisting>
Error: JavaFX runtime components are missing, and are required to run this application
                            </programlisting>
                            Ennek orvoslása érdekében el kell navigálni a projekt <emphasis role="strong"><![CDATA[Properties -> Run]]></emphasis> menüpontjába, ahol a 
                            következő sort kell beilleszteni a <emphasis role="strong"><![CDATA[VM options]]></emphasis> mezőbe:
                            <programlisting>
--module-path /path/to/javafx-sdk-12/lib --add-modules javafx.controls,javafx.fxml
                            </programlisting>
                            <figure>
                                    <title>VM opciók hozzáadása</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/VMoptions.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                            Erre azért van szükség, mert a fő osztályunknak az őse a javafx.application.Application osztály. Emiatt kell megadnunk a <function>module-path</function>-t is.
                            Ezután már sikeresen el fog indulni a programod.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            De ha nem, akkor a következőt kell tenned. Menj a <emphasis role="strong"><![CDATA[Properties -> Build -> Compiling]]></emphasis> menüpontba, majd 
                            pipáld ki a <function>Compile on Save</function> opciót.
                            <figure>
                                    <title>Rejtett hibalehetőség</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/errormaker.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                            Ezután már tényleg futni fog a program.
                        </para>
                    </listitem>
                </orderedlist>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Mivel a feldat az volt, hogy módosítsuk a megadott programot, ezért részletsen nem tárgyaljuk a program működését. A lényeg, hogy vannak tevékenységeink, melyekhez 
            tulajdonságokat tudunk társítani. A tulajdonságokhoz pedig értékeket adunk meg.
        </para>
        <para>
            Lássuk, hogy milyen módosításokat végeztünk. Az első, manapság egyre gyakoribb lehetőség a sötét mód lehetővététele volt. JavaFX-ben ezt CSS stíluslapokkal tudjuk megoldani.
            A szükséges stílus információkat a <filename>style.css</filename> fájl tartalmazza.
            <programlisting>
                    .root { 
                        -fx-accent: #eba308;
                        -fx-focus-color: -fx-accent;
                        -fx-base: #111;
                        -fx-control-inner-background: derive(-fx-base,50%);
                        -fx-control-inner-background-alt: derive(-fx-control-inner-background, 30%);
                    }
                    
                    .label{
                        -fx-text-fill: lightgray;
                    }
                    
                    .separator *.line { 
                        -fx-background-color: #3C3C3C;
                        -fx-border-style: solid;
                        -fx-border-width: 1px;
                    }
                    
                    .scroll-bar{
                        -fx-background-color: derive(-fx-base,45%)
                    }
                    
                    .button:default {
                        -fx-base: -fx-accent ;
                    } 
                    
                    .table-view{
                        -fx-background-color: derive(-fx-base, 10%);
                        -fx-selection-bar-non-focused: derive(-fx-base, 85%);
                    }
                        
                        . . .

            </programlisting>
            Ahhoz, hogy ezt a stíluslapot használja a programunk, a következő változtatást kellett eszközölni az <classname>ActivityEditor</classname> osztályban:
            <programlisting language="java">
scene.getStylesheets().add("style.css");
            </programlisting>
            3 fő widgetből áll a 
            programunk. Az egyik a <classname>FileTree</classname>, mely a mappaszerkezetet tartalmazza, ezen keresztül érhetjük el a 
            tevékenységeket. A másik a <classname>StringTree</classname>, mely a tulajdonságokat tartalmazza, amik a tevékenységekhez adhatóak hozzá.
            Az utolsó widget pedig egy szövegdoboz, mely megmutatja a tevékenységekhez tartozó fájl tartalmát, és kezdetben szerkeszthető is.
            Az ablak egyes elemeit csoportosítottuk. Az eredeti verzióban külön váltak a widgetek és azokhoz tartozó nevek. Ezt úgy vontuk össze, 
            hogy létrehoztunk egy <classname>VBox</classname> réteget. Ez a réteg azért megfelelő, mert az egyes elemeket egymás alatt jeleníti meg. Ehhez hozzáadtuk a widgetet és a nevét tartalmazó cimkét.
            Összevonás megvalósítása a szövegdobozon:
            <programlisting language="java"><![CDATA[
javafx.scene.control.Label actPropsLabel = new javafx.scene.control.Label("A tevékenységekhez hozzárendelt tulajdonságok");
javafx.scene.control.TextArea propsEdit = new javafx.scene.control.TextArea();
javafx.scene.layout.VBox propsEditLayout = new javafx.scene.layout.VBox();
propsEditLayout.getChildren().add(actPropsLabel);
propsEditLayout.getChildren().add(propsEdit);]]>            
            </programlisting>
            A másik két widgetet az eredetitől eltérően nem egymás alatt, hanem egymás mellett szeretnénk megjeleníteni, ezért egy újabb réteget kellett létrehozni.
            Mivel, most vízszintesen szeretnénk elhelyezni az elemeket, ezért <classname>HBox</classname> osztályt használjuk.
            <programlisting language="java"><![CDATA[
javafx.scene.layout.HBox treesLayout = new javafx.scene.layout.HBox();
treesLayout.prefHeightProperty().bind(box.heightProperty());
treesLayout.prefWidthProperty().bind(box.widthProperty());

javafx.scene.control.TreeView<String> stringTree = new StringTree(properties, true, propsEdit);
javafx.scene.layout.VBox stringTreeLayout = new javafx.scene.layout.VBox();
stringTree.prefHeightProperty().bind(treesLayout.heightProperty());
stringTreeLayout.prefHeightProperty().bind(treesLayout.heightProperty());
stringTreeLayout.prefWidthProperty().bind(treesLayout.widthProperty());
stringTree.setEditable(false);
stringTreeLayout.getChildren().add(new javafx.scene.control.Label("Tulajdonságok fája"));
stringTreeLayout.getChildren().add(stringTree);

javafx.scene.control.TreeView<java.io.File> fileTree = new FileTree(city, true, propsEdit, propsEditLayout, actPropsLabel);
javafx.scene.layout.VBox fileTreeLayout = new javafx.scene.layout.VBox();
fileTree.prefHeightProperty().bind(treesLayout.heightProperty());
fileTreeLayout.prefHeightProperty().bind(treesLayout.heightProperty());
fileTreeLayout.prefWidthProperty().bind(treesLayout.widthProperty());
fileTreeLayout.getChildren().add(new javafx.scene.control.Label("Tevékenységek fája és a tevékenységekhez hozzárendelt tulajdonságok"));
fileTreeLayout.getChildren().add(fileTree);
fileTree.setEditable(true);

treesLayout.getChildren().add(fileTreeLayout);
treesLayout.getChildren().add(stringTreeLayout);]]>            
            </programlisting>
            Ahogy látható képesek vagyunk rétegekhez új rétegeket hozzáadni. Végezetül a <varname>treesLayout</varname>-ot és a <varname>propsEditLayout</varname> fogjuk 
            hozzáadni a fő réteghez, a <varname>box</varname>-hoz, mely szintén egy <classname>VBox</classname>. Ahhoz, hogy biztosítsuk az egyes rétegek megefelelő
            átméretezését az ablak átméretezése során a <function>bind</function> függvényt használhatjuk. Ezzel azt tudjuk elérni, hogy a paraméterként megadott objektummal
            együtt változzon az egyes rétegek mérete.
            Példa a forrásból:
            <programlisting language="java">
fileTreeLayout.prefHeightProperty().bind(treesLayout.heightProperty());
fileTreeLayout.prefWidthProperty().bind(treesLayout.widthProperty());
            </programlisting>
        </para>
        <para>
            Az eredeti verzióban az egyes tulajdonságokhoz tartozó értéket nekünk kellett külön begépelni a <varname>propsEdit</varname> widgeten keresztül, és nem 
            volt garantált, hogy a felhasználó biztosan megad valamilyen számértéket. Ezt úgy oldottuk meg, hogy amikor hozzá akarunk adni egy tulajdonságot egy tevékenységhez, 
            akkor egy <classname>TextInputDialog</classname> ablak jelenik meg. Ezek a módosítások a <classname>StringTree</classname> osztályban találhatóak.
            <programlisting language="java"><![CDATA[
setOnMouseClicked((javafx.scene.input.MouseEvent mouseEvent) -> {
    {
        if (mouseEvent.getClickCount() == 2) {
            javafx.scene.control.TreeItem<String> item = getSelectionModel().getSelectedItem();
            if (item != null) {
                javafx.scene.control.TextInputDialog dialog = new javafx.scene.control.TextInputDialog("Add meg az értéket!");
                dialog.setTitle("Érték megadása");
                dialog.setHeaderText(item.getValue());
                dialog.setContentText("Érték (0-100)");

                java.util.Optional<String> result = dialog.showAndWait();

                result.ifPresent(name -> {
                    propsEdit.appendText(item.getValue() + " " + name);
                    propsEdit.appendText(System.getProperty("line.separator"));

                });
            }
        }
    }
});]]>            
            </programlisting>
            Ha nem adod meg az ablak címét és feljlécét, akkor egy alapértelmezett verziót generál a program. Viszont jelen állapotában bármilyen bemenetet elfogad, ami nem 
            kívánatos. Ezt úgy érjük el, hogy egészen addig nem lehet az OK gombra nyomni, ameddig a bemenet nem megfelelő. A bemenete folyamataos ellenőrzését a következő
            kódrészlet muataja be:
            <programlisting language="java"><![CDATA[
javafx.scene.Node okButton = dialog.getDialogPane().lookupButton(javafx.scene.control.ButtonType.OK);
okButton.setDisable(true);
javafx.scene.control.TextField inputField = dialog.getEditor();
inputField.textProperty().addListener((observable, oldValue, newValue) -> {
    okButton.setDisable(isInvalid(newValue));
});]]>
            </programlisting>
            Az OK gombot alapértelmezetten kikapcsoljuk, hogy ne fogadja el a bemenetet az első alkalomra se. Utána pedig akkor, futtajuk a vizsgálatot, ha változott a szöveg a 
            mezőben. Ennek ellenőrzését a <function>addListener</function> függvény segítségével oldjuk meg. Maga az ellenőrző függvény pedig a következő:
            <programlisting language="java"><![CDATA[
private boolean isInvalid(String text) {
    try {
        int d = Integer.parseInt(text);
    } catch (NumberFormatException | NullPointerException nfe) {
        return true;
    }
    if(Integer.parseInt(text) < 0 || Integer.parseInt(text) > 100) return true;
    return false;
}]]>               
            </programlisting>
            Elsőnek azt vizsgáljuk, hogy egyáltalán számmá alakítható-e a bemenet. Ha nem, akkor igaz értékkel térünk vissza. Viszont az sem jó nekünk, ha a felhasználó 
            negatív, vagy 100-nál nagyobb értéket ad meg. Ekkot is igaz értékkel térünk vissza. Ha minegyik teszten átmegy a bemenet, akkor pedig hamissal térünk vissza.
            A logika fordítottnak tűnhet, de a <function>isInValid</function> függvény azt vizsgálja, hogy nem megfelelő-e az megadott érték. 
        </para>
        <para>
            A <varname>propsEdit</varname> widget csak akkor jelenít meg tartalmat, amikor egy fájlra kattintunk rá a <varname>fileTree</varname> widgetben. Tehát 
            fölösleges folyamatosan megjeleníteni. Ezért csak akkor fog megjelenni, ha tényleg szükség van rá. A módosítások a következőek:
            <programlisting language="java"><![CDATA[
//ActivityEditor.java
public void start(javafx.stage.Stage stage) {
    ...
    propsEditLayout.setVisible(false);
    propsEditLayout.managedProperty().bind(propsEditLayout.visibleProperty());
    propsEdit.setEditable(false);
    ...
}

//FileTree.java
setOnMouseClicked((javafx.scene.input.MouseEvent evt) -> {

    if (evt.getClickCount() == 1) {

        javafx.scene.control.TreeItem<java.io.File> item = getSelectionModel().getSelectedItem();

        if (item != null) {

            java.io.File f = item.getValue();

            try {
                java.util.Scanner scanner = new java.util.Scanner(f);
                StringBuilder fileContents = new StringBuilder();
                while (scanner.hasNextLine()) {
                    fileContents.append(scanner.nextLine());
                    fileContents.append(System.getProperty("line.separator"));

                }
                scanner.close();
                
                System.out.println("File");
                
                propsEditLayout.setVisible(true);
                
                save(propsEdit, actPropsLabel);
                
                actPropsLabel.setText(f.getPath());
                propsEdit.setVisible(true);
                propsEdit.setText(fileContents.toString());

            } catch (java.io.FileNotFoundException fnfE) {
                
                propsEditLayout.setVisible(false);
                save(propsEdit, actPropsLabel);

                propsEdit.setText("");
                actPropsLabel.setText("");

            }]]>
            </programlisting>
            Azt már korábban megoldottuk, hogy ne lehessen bármilyen értéket adni az egyes tulajdonságokhoz. Viszont a <varname>propsEdit</varname>-ben teljesen át tudjuk alakítani
            a fájlok tartalmát. Akár új, a programban nem létező tulajdonságokat tudunk beleírni.
            Mivel ezt a területet nem szeretnénk, hogy szerkeszthető legyen, ezért kikapcsoltuk a szerkesztési lehetőséget.
            <programlisting language="java"><![CDATA[
//ActivityEditor.java
public void start(javafx.stage.Stage stage) {
    ...
    propsEdit.setEditable(false);
    ...
}]]>
            </programlisting>
            Az utolsó simítás pedig az, hogy csak akkor tudjunk tulajdonságot hozzáadni a tevékenységhez, ha már kiválasztottuk a fájl, amit szerkeszteni szeretnénk. Emiatt a 
            <varname>stringTreeLayout</varname> réteget kikapcsoljuk, és csak a <varname>propsEdit</varname> megjelenésével együtt kapcsoljuk vissza.
            <programlisting language="java"><![CDATA[
//ActivityEditor.java
public void start(javafx.stage.Stage stage) {
    ...
    stringTreeLayout.setDisable(true);
    ...
}

//FileTree.java
setOnMouseClicked((javafx.scene.input.MouseEvent evt) -> {
                ...
                
                propsEditLayout.setVisible(true);
                stringTreeLayout.setDisable(false);
                
                ...

            } catch (java.io.FileNotFoundException fnfE) {
                
                stringTreeLayout.setDisable(true);
                propsEditLayout.setVisible(false);
                
                ...
            }
        }]]>
            </programlisting>
            <figure>
                    <title>Végeredmény</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/program.png" format="PNG" scale="160"/>
                            </imageobject>
                        </mediaobject>
            </figure>                    
        </para>
    </section>        

    <section>
        <title>OOCWC Boost ASIO hálózatkezelése</title> <!-- Egy megoldási javaslat, hogy írjuk át Protobufferes kommunikációra-->
        <para>
            Mutassunk rá a scanf szerepére és használatára! <link xlink:href="https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll">https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        
        
    <section>
        <title>SamuCam</title>
        <para>
            Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben:
            <link xlink:href="https://github.com/nbatfai/SamuCam">https://github.com/nbatfai/SamuCam</link>  
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    <section>
        <title>BrainB</title> <!-- A számítás osztály van összekapcsolva az ablakkal -->
        <para>
            Mutassuk be a Qt slot-signal mechanizmust ebben a projektben: <link xlink:href="https://github.com/nbatfai/esporttalent-search">https://github.com/nbatfai/esporttalent-search</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        

    <section>
        <title>OSM térképre rajzolása</title> <!-- Ebből éredmes az androidosat választani -->
        <para>
            Debrecen térképre dobjunk rá cuccokat, ennek mintájára, ahol én az országba helyeztem el a DEAC
            hekkereket: <link xlink:href="https://www.twitch.tv/videos/182262537">https://www.twitch.tv/videos/182262537</link> (de az OOCWC Java Swinges
            megjelenítőjéből: <link xlink:href="https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin">https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin</link> is
            kiindulhatsz, mondjuk az komplexebb, mert ott időfejlődés is van...)
        </para>
        <para>
            Alternatívaként készíthetsz egy GoogleMaps alapú Androidos „GPS trackert”, 2007 óta csinálok ilyen példát:
            <link xlink:href="https://youtu.be/QStgBZ6JfAU">https://youtu.be/QStgBZ6JfAU</link> az aktuális a Bátfai Haxor Stream keretében:
            <link xlink:href="https://bhaxor.blog.hu/2018/09/19/nandigps_ismerkedes_a_gps-el">https://bhaxor.blog.hu/2018/09/19/nandigps_ismerkedes_a_gps-el</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        

</chapter>                
