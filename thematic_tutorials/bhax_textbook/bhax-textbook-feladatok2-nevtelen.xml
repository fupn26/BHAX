<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló,...!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
            Javítsunk valamit a ActivityEditor.java JavaFX programon!
            <link xlink:href="https://github.com/nbatfai/future/tree/master/cs/F6">https://github.com/nbatfai/future/tree/master/cs/F6</link>
        </para>
        <para>
            Itt láthatjuk működésben az alapot: <link xlink:href="https://www.twitch.tv/videos/222879467">https://www.twitch.tv/videos/222879467</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <caution>
            <title>Megjegyzés</title>
            <para>
                Tutorált: Pallagi Ádám
            </para>
        </caution>
        <para>
            <emphasis role="strong">JavaFx beizzítása NetBeans-ben</emphasis>
        </para>
        <para>
                Ez a leírás azért szükséges, mert a JavaFx már nem része a Java JDK-nak. Én a programomhoz a Java JDK 11-et és a JavaFX 11-et használtam.
                <orderedlist>
                    <listitem>
                        <para>Elsőnek töltsd le a JavaFX SDK-t a következő oldalról:<link xlink:href="https://gluonhq.com/products/javafx/">https://gluonhq.com/products/javafx/</link></para>
                    </listitem>
                    <listitem>
                        <para>
                            Következő lépés, hogy a JavaFX <filename>*.jar</filename> fájljait láthatóvá tesszük a NetBeans számára.
                            Ehhez a <emphasis role="strong"><![CDATA[Tools -> Libraries]]></emphasis> menüpontba kell navigálni. Ahol
                            létre kell hozni egy új könyvtárat, és hozzáadni a <filename>*.jar</filename> fájlokat.
                            <figure>
                                    <title>JavaFX könyvtár létrehozása</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/createlibrary.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Létrehozunk egy új ANT projektet (simát, nem JavaFX-eset), majd a projekten belül a <emphasis role="strong"><![CDATA[Libraries]]></emphasis>-ra kattintva jobb egérgombbal a 
                            <emphasis role="strong"><![CDATA[Add Library]]></emphasis> lépéseket
                            követve hozzáadjuk a korábban létrehozott könyvtárat.
                            <figure>
                                    <title>JavaFX könyvtár hozzáadása a projekthez</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/addlibrary.png" format="PNG" scale="90"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Most, ha futtatod a programod, hibát fogsz kapni.
                            <programlisting>
Error: JavaFX runtime components are missing, and are required to run this application
                            </programlisting>
                            Ennek orvoslása érdekében el kell navigálni a projekt <emphasis role="strong"><![CDATA[Properties -> Run]]></emphasis> menüpontjába, ahol a 
                            következő sort kell beilleszteni a <emphasis role="strong"><![CDATA[VM options]]></emphasis> mezőbe:
                            <programlisting>
--module-path /path/to/javafx-sdk-12/lib --add-modules javafx.controls,javafx.fxml
                            </programlisting>
                            <figure>
                                    <title>VM opciók hozzáadása</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/VMoptions.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                            Erre azért van szükség, mert a fő osztályunknak az őse a javafx.application.Application osztály. Emiatt kell megadnunk a <function>module-path</function>-t is.
                            Ezután már sikeresen el fog indulni a programod.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            De ha nem, akkor a következőt kell tenned. Menj a <emphasis role="strong"><![CDATA[Properties -> Build -> Compiling]]></emphasis> menüpontba, majd 
                            pipáld ki a <function>Compile on Save</function> opciót.
                            <figure>
                                    <title>Rejtett hibalehetőség</title>
                                        <mediaobject>
                                            <imageobject>
                                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/JavaFX_help/errormaker.png" format="PNG"/>
                                            </imageobject>
                                        </mediaobject>
                            </figure>                    
                            Ezután már tényleg futni fog a program.
                        </para>
                    </listitem>
                </orderedlist>
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Mivel a feldat az volt, hogy módosítsuk a megadott programot, ezért részletsen nem tárgyaljuk a program működését. A lényeg, hogy vannak tevékenységeink, melyekhez 
            tulajdonságokat tudunk társítani. A tulajdonságokhoz pedig értékeket adunk meg.
        </para>
        <para>
            Lássuk, hogy milyen módosításokat végeztünk. Az első, manapság egyre gyakoribb lehetőség a sötét mód lehetővététele volt. JavaFX-ben ezt CSS stíluslapokkal tudjuk megoldani.
            A szükséges stílus információkat a <filename>style.css</filename> fájl tartalmazza.
            <programlisting>
                    .root { 
                        -fx-accent: #eba308;
                        -fx-focus-color: -fx-accent;
                        -fx-base: #111;
                        -fx-control-inner-background: derive(-fx-base,50%);
                        -fx-control-inner-background-alt: derive(-fx-control-inner-background, 30%);
                    }
                    
                    .label{
                        -fx-text-fill: lightgray;
                    }
                    
                    .separator *.line { 
                        -fx-background-color: #3C3C3C;
                        -fx-border-style: solid;
                        -fx-border-width: 1px;
                    }
                    
                    .scroll-bar{
                        -fx-background-color: derive(-fx-base,45%)
                    }
                    
                    .button:default {
                        -fx-base: -fx-accent ;
                    } 
                    
                    .table-view{
                        -fx-background-color: derive(-fx-base, 10%);
                        -fx-selection-bar-non-focused: derive(-fx-base, 85%);
                    }
                        
                        . . .

            </programlisting>
            Ahhoz, hogy ezt a stíluslapot használja a programunk, a következő változtatást kellett eszközölni az <classname>ActivityEditor</classname> osztályban:
            <programlisting language="java">
scene.getStylesheets().add("style.css");
            </programlisting>
            3 fő widgetből áll a 
            programunk. Az egyik a <classname>FileTree</classname>, mely a mappaszerkezetet tartalmazza, ezen keresztül érhetjük el a 
            tevékenységeket. A másik a <classname>StringTree</classname>, mely a tulajdonságokat tartalmazza, amik a tevékenységekhez adhatóak hozzá.
            Az utolsó widget pedig egy szövegdoboz, mely megmutatja a tevékenységekhez tartozó fájl tartalmát, és kezdetben szerkeszthető is.
            Az ablak egyes elemeit csoportosítottuk. Az eredeti verzióban külön váltak a widgetek és azokhoz tartozó nevek. Ezt úgy vontuk össze, 
            hogy létrehoztunk egy <classname>VBox</classname> réteget. Ez a réteg azért megfelelő, mert az egyes elemeket egymás alatt jeleníti meg. Ehhez hozzáadtuk a widgetet és a nevét tartalmazó cimkét.
            Összevonás megvalósítása a szövegdobozon:
            <programlisting language="java"><![CDATA[
javafx.scene.control.Label actPropsLabel = new javafx.scene.control.Label("A tevékenységekhez hozzárendelt tulajdonságok");
javafx.scene.control.TextArea propsEdit = new javafx.scene.control.TextArea();
javafx.scene.layout.VBox propsEditLayout = new javafx.scene.layout.VBox();
propsEditLayout.getChildren().add(actPropsLabel);
propsEditLayout.getChildren().add(propsEdit);]]>            
            </programlisting>
            A másik két widgetet az eredetitől eltérően nem egymás alatt, hanem egymás mellett szeretnénk megjeleníteni, ezért egy újabb réteget kellett létrehozni.
            Mivel, most vízszintesen szeretnénk elhelyezni az elemeket, ezért <classname>HBox</classname> osztályt használjuk.
            <programlisting language="java"><![CDATA[
javafx.scene.layout.HBox treesLayout = new javafx.scene.layout.HBox();
treesLayout.prefHeightProperty().bind(box.heightProperty());
treesLayout.prefWidthProperty().bind(box.widthProperty());

javafx.scene.control.TreeView<String> stringTree = new StringTree(properties, true, propsEdit);
javafx.scene.layout.VBox stringTreeLayout = new javafx.scene.layout.VBox();
stringTree.prefHeightProperty().bind(treesLayout.heightProperty());
stringTreeLayout.prefHeightProperty().bind(treesLayout.heightProperty());
stringTreeLayout.prefWidthProperty().bind(treesLayout.widthProperty());
stringTree.setEditable(false);
stringTreeLayout.getChildren().add(new javafx.scene.control.Label("Tulajdonságok fája"));
stringTreeLayout.getChildren().add(stringTree);

javafx.scene.control.TreeView<java.io.File> fileTree = new FileTree(city, true, propsEdit, propsEditLayout, actPropsLabel);
javafx.scene.layout.VBox fileTreeLayout = new javafx.scene.layout.VBox();
fileTree.prefHeightProperty().bind(treesLayout.heightProperty());
fileTreeLayout.prefHeightProperty().bind(treesLayout.heightProperty());
fileTreeLayout.prefWidthProperty().bind(treesLayout.widthProperty());
fileTreeLayout.getChildren().add(new javafx.scene.control.Label("Tevékenységek fája és a tevékenységekhez hozzárendelt tulajdonságok"));
fileTreeLayout.getChildren().add(fileTree);
fileTree.setEditable(true);

treesLayout.getChildren().add(fileTreeLayout);
treesLayout.getChildren().add(stringTreeLayout);]]>            
            </programlisting>
            Ahogy látható képesek vagyunk rétegekhez új rétegeket hozzáadni. Végezetül a <varname>treesLayout</varname>-ot és a <varname>propsEditLayout</varname> fogjuk 
            hozzáadni a fő réteghez, a <varname>box</varname>-hoz, mely szintén egy <classname>VBox</classname>. Ahhoz, hogy biztosítsuk az egyes rétegek megefelelő
            átméretezését az ablak átméretezése során a <function>bind</function> függvényt használhatjuk. Ezzel azt tudjuk elérni, hogy a paraméterként megadott objektummal
            együtt változzon az egyes rétegek mérete.
            Példa a forrásból:
            <programlisting language="java">
fileTreeLayout.prefHeightProperty().bind(treesLayout.heightProperty());
fileTreeLayout.prefWidthProperty().bind(treesLayout.widthProperty());
            </programlisting>
        </para>
        <para>
            Az eredeti verzióban az egyes tulajdonságokhoz tartozó értéket nekünk kellett külön begépelni a <varname>propsEdit</varname> widgeten keresztül, és nem 
            volt garantált, hogy a felhasználó biztosan megad valamilyen számértéket. Ezt úgy oldottuk meg, hogy amikor hozzá akarunk adni egy tulajdonságot egy tevékenységhez, 
            akkor egy <classname>TextInputDialog</classname> ablak jelenik meg. Ezek a módosítások a <classname>StringTree</classname> osztályban találhatóak.
            <programlisting language="java"><![CDATA[
setOnMouseClicked((javafx.scene.input.MouseEvent mouseEvent) -> {
    {
        if (mouseEvent.getClickCount() == 2) {
            javafx.scene.control.TreeItem<String> item = getSelectionModel().getSelectedItem();
            if (item != null) {
                javafx.scene.control.TextInputDialog dialog = new javafx.scene.control.TextInputDialog("Add meg az értéket!");
                dialog.setTitle("Érték megadása");
                dialog.setHeaderText(item.getValue());
                dialog.setContentText("Érték (0-100)");

                java.util.Optional<String> result = dialog.showAndWait();

                result.ifPresent(name -> {
                    propsEdit.appendText(item.getValue() + " " + name);
                    propsEdit.appendText(System.getProperty("line.separator"));

                });
            }
        }
    }
});]]>            
            </programlisting>
            Ha nem adod meg az ablak címét és feljlécét, akkor egy alapértelmezett verziót generál a program. Viszont jelen állapotában bármilyen bemenetet elfogad, ami nem 
            kívánatos. Ezt úgy érjük el, hogy egészen addig nem lehet az OK gombra nyomni, ameddig a bemenet nem megfelelő. A bemenete folyamataos ellenőrzését a következő
            kódrészlet muataja be:
            <programlisting language="java"><![CDATA[
javafx.scene.Node okButton = dialog.getDialogPane().lookupButton(javafx.scene.control.ButtonType.OK);
okButton.setDisable(true);
javafx.scene.control.TextField inputField = dialog.getEditor();
inputField.textProperty().addListener((observable, oldValue, newValue) -> {
    okButton.setDisable(isInvalid(newValue));
});]]>
            </programlisting>
            Az OK gombot alapértelmezetten kikapcsoljuk, hogy ne fogadja el a bemenetet az első alkalomra se. Utána pedig akkor, futtajuk a vizsgálatot, ha változott a szöveg a 
            mezőben. Ennek ellenőrzését a <function>addListener</function> függvény segítségével oldjuk meg. Maga az ellenőrző függvény pedig a következő:
            <programlisting language="java"><![CDATA[
private boolean isInvalid(String text) {
    try {
        int d = Integer.parseInt(text);
    } catch (NumberFormatException | NullPointerException nfe) {
        return true;
    }
    if(Integer.parseInt(text) < 0 || Integer.parseInt(text) > 100) return true;
    return false;
}]]>               
            </programlisting>
            Elsőnek azt vizsgáljuk, hogy egyáltalán számmá alakítható-e a bemenet. Ha nem, akkor igaz értékkel térünk vissza. Viszont az sem jó nekünk, ha a felhasználó 
            negatív, vagy 100-nál nagyobb értéket ad meg. Ekkot is igaz értékkel térünk vissza. Ha minegyik teszten átmegy a bemenet, akkor pedig hamissal térünk vissza.
            A logika fordítottnak tűnhet, de a <function>isInValid</function> függvény azt vizsgálja, hogy nem megfelelő-e az megadott érték. 
        </para>
        <para>
            A <varname>propsEdit</varname> widget csak akkor jelenít meg tartalmat, amikor egy fájlra kattintunk rá a <varname>fileTree</varname> widgetben. Tehát 
            fölösleges folyamatosan megjeleníteni. Ezért csak akkor fog megjelenni, ha tényleg szükség van rá. A módosítások a következőek:
            <programlisting language="java"><![CDATA[
//ActivityEditor.java
public void start(javafx.stage.Stage stage) {
    ...
    propsEditLayout.setVisible(false);
    propsEditLayout.managedProperty().bind(propsEditLayout.visibleProperty());
    propsEdit.setEditable(false);
    ...
}

//FileTree.java
setOnMouseClicked((javafx.scene.input.MouseEvent evt) -> {

    if (evt.getClickCount() == 1) {

        javafx.scene.control.TreeItem<java.io.File> item = getSelectionModel().getSelectedItem();

        if (item != null) {

            java.io.File f = item.getValue();

            try {
                java.util.Scanner scanner = new java.util.Scanner(f);
                StringBuilder fileContents = new StringBuilder();
                while (scanner.hasNextLine()) {
                    fileContents.append(scanner.nextLine());
                    fileContents.append(System.getProperty("line.separator"));

                }
                scanner.close();
                
                System.out.println("File");
                
                propsEditLayout.setVisible(true);
                
                save(propsEdit, actPropsLabel);
                
                actPropsLabel.setText(f.getPath());
                propsEdit.setVisible(true);
                propsEdit.setText(fileContents.toString());

            } catch (java.io.FileNotFoundException fnfE) {
                
                propsEditLayout.setVisible(false);
                save(propsEdit, actPropsLabel);

                propsEdit.setText("");
                actPropsLabel.setText("");

            }]]>
            </programlisting>
            Azt már korábban megoldottuk, hogy ne lehessen bármilyen értéket adni az egyes tulajdonságokhoz. Viszont a <varname>propsEdit</varname>-ben teljesen át tudjuk alakítani
            a fájlok tartalmát. Akár új, a programban nem létező tulajdonságokat tudunk beleírni.
            Mivel ezt a területet nem szeretnénk, hogy szerkeszthető legyen, ezért kikapcsoltuk a szerkesztési lehetőséget.
            <programlisting language="java"><![CDATA[
//ActivityEditor.java
public void start(javafx.stage.Stage stage) {
    ...
    propsEdit.setEditable(false);
    ...
}]]>
            </programlisting>
            Az utolsó simítás pedig az, hogy csak akkor tudjunk tulajdonságot hozzáadni a tevékenységhez, ha már kiválasztottuk a fájl, amit szerkeszteni szeretnénk. Emiatt a 
            <varname>stringTreeLayout</varname> réteget kikapcsoljuk, és csak a <varname>propsEdit</varname> megjelenésével együtt kapcsoljuk vissza.
            <programlisting language="java"><![CDATA[
//ActivityEditor.java
public void start(javafx.stage.Stage stage) {
    ...
    stringTreeLayout.setDisable(true);
    ...
}

//FileTree.java
setOnMouseClicked((javafx.scene.input.MouseEvent evt) -> {
                ...
                
                propsEditLayout.setVisible(true);
                stringTreeLayout.setDisable(false);
                
                ...

            } catch (java.io.FileNotFoundException fnfE) {
                
                stringTreeLayout.setDisable(true);
                propsEditLayout.setVisible(false);
                
                ...
            }
        }]]>
            </programlisting>
            <figure>
                    <title>Végeredmény</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="../../attention_raising/Source/FutureJavaFX/program.png" format="PNG" scale="160"/>
                            </imageobject>
                        </mediaobject>
            </figure>                    
        </para>
    </section>        

    <section>
        <title>OOCWC Boost ASIO hálózatkezelése</title> <!-- Egy megoldási javaslat, hogy írjuk át Protobufferes kommunikációra-->
        <para>
            Mutassunk rá a scanf szerepére és használatára! <link xlink:href="https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll">https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Már korábban beszéltünk arról, hogy az OOCWC projetk lexerjében mire használjuk a <function>sscanf</function>-et. Ez a függvény egy formázott sztringet vár
            bemenetéül. Az első paramétere az a sztring, amiből olvassa a bemenetet, a többi paraméterrel pedig azt adjuk meg, hogyan tárolja azt.
            Lássunk egy példát az OOCWC projekt <filename>myshmclient.cpp</filename> fájljából.
            <programlisting language="c++"><![CDATA[
while ( std::sscanf ( data+nn, "<OK %d %u %u %u>%n", &idd, &f, &t, &s, &n ) == 4 )
    {
        nn += n;
        gangsters.push_back ( Gangster {idd, f, t, s} );
    }]]>                
            </programlisting>
            Ebben az esetben olyan stringet olvasunk be, amely <![CDATA[<OK]]>-val kezdődik. Utána várunk egy egészt, és 3 előjel nélküli egészt. Az utolsó paraméter az 
            érdekesebb, hiszen az eddigiekkel már találkozhattunk a <function>printf</function> használatakor is. Az utolsó paraméternek egy olyan egészt adunk meg, melyben a 
            <function>sscanf</function> a beolvasott bájtok számát adja meg. Ezt tároljuk el az <varname>n</varname> változóban. Értékét arra használjuk fel, hogy 
            a beolvasni kívánt sztingen tovább lépjünk, ne olvassuk be újra ugyanazt az elemet. Azért van arra szükség, hogy ezt a beolvasást egy 
            cikluson belül hajtsuk végre, mert nem tudhatjuk biztosan, hogy hány gengszter van a térképen. A ciklus addig folytatódik, ameddig a 
            az argumentumlista 4 elemének értéket tud adni. Ugyanis a <function>sscanf</function> sikeres beolvasás esetén a 
            helyesen "kitöltött" elemek számát adja vissza.   
        </para>
    </section>        
        
    <section>
        <title>SamuCam</title>
        <para>
            Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben:
            <link xlink:href="https://github.com/nbatfai/SamuCam">https://github.com/nbatfai/SamuCam</link>  
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/SamuCam">https://github.com/nbatfai/SamuCam</link>                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <caution>
            <title>OpenCV telepítése</title>
            <para>
                <programlisting>sudo apt install libopencv-dev</programlisting>
            </para>
        </caution>
        <para>
            Ebben a feladatban arról lesz szó, hogy az OpenCV segítségével hogyan tudjuk kezelni a webkameránkat, és annak adatait feldolgozni.
            Ha csatlakoztatva van webkamera a gépedhez, akkor érdemes telepíteni a <function>Motion</function> alkalmazást, mely segítségével egy 
            webkamera servert indíthatsz a géped 8081-es portján. Részletes leírásért lásd: <link xlink:href="https://www.maketecheasier.com/setup-motion-detection-webcam-ubuntu/">https://www.maketecheasier.com/setup-motion-detection-webcam-ubuntu/</link>
            Ha viszont nincs webkamerád, akkor jó lesz a telefonod kamerája is, ehhez le kell töltened az <function>IP Webcam</function> alkalmazást.
            Bármelyiket is választod, a forrsában a következő részt módosítanod kell a megfelelő IP címre:
            <programlisting language="c++"><![CDATA[
//main.cpp
int main ( int argc, char** argv )
{
    ...

    QCommandLineOption webcamipOption ( QStringList() << "ip" << "webcamip",
                                        QCoreApplication::translate ( "main", "Specify IP address of your IP webcam app on Android phone (default is http://192.168.0.18:8080/video?x.mjpeg)." ),
                                      QCoreApplication::translate ( "main", "webcamip" ), "http://192.168.0.100:8080/video?x.mjpeg" ); //ezt kell módosítani

    ...
}]]>
            </programlisting>
            Emellett még szükség lesz a <filename>lbpcascade_frontalface.xml</filename> fájlra, mely a <link xlink:href="https://github.com/Itseez/opencv/tree/master/data/lbpcascades">https://github.com/Itseez/opencv/tree/master/data/lbpcascades</link>
            oldalon érhető el. Ezt a projekt mappájába kell helyezned, hogy megtalálj a program. 
        </para>
        <para>
            Ahhoz, hogy hozzá tudjunk férni a kameránk áltak biztosított adatokhoz, a <classname>cv::VideoCapture</classname> osztály van segítségünkre. Ahhoz, hogy megnyissuk a 
            webkamera servere által biztosított felvételt, a <function>SamuCam::openVideoStream()</function> függvényt használjuk.
            <programlisting language="c++"><![CDATA[
void SamuCam::openVideoStream()
{
    videoCapture.open ( videoStream );


    videoCapture.set ( CV_CAP_PROP_FRAME_WIDTH, width );
    videoCapture.set ( CV_CAP_PROP_FRAME_HEIGHT, height );
    videoCapture.set ( CV_CAP_PROP_FPS, 10 );
}]]>
            </programlisting>
            Az <function>open</function> függvénynek paraméteréül adhatjuk a kameránk számát, a nulla az alapértelmezett kamera, ami elérhető a gépen. De adhatunk meg 
            videó fájlt vagy ahogy a <function>SamuCam</function> osztályban látható, IP címet is. A <function>set</function> függvénnyel pedig tulajdonságokat tudunk megadni a
            <varname>videoCapture</varname> objektumunknak. Jelen esetben azt, hogy milyen méretben jelenítse meg a kameránk képét, és korlátozatjuk az FPS számot is.  
        </para>
        <para>
            Ahogy feljebb említettem szükség van a program megfelelő működéséhez a <filename>lbpcascade_frontalface.xml</filename> fájlra. Mégpedig azért, mert a
            program arcfelismerésen alapul, melyet a <classname>cv::CascadeClassifier</classname> osztály tesz lehetővé. Ez az osztály kifejezetten objektumok felismerését valósítja 
            meg. Az xml fájlon keresztül adjuk meg neki, hogy milyen felimerést szeretnénk használni.  
            Annyi a lényeg, hogyha a <varname>faceClassifier</varname>
            objektum egy emberi arcot ismer fel a kamera képén, akkor arról készít egy másolatot, és megjeleníti a képernyőn. Lássuk a <classname>SamuCam</classname> osztály
            <function>run</function> függvényét, melyben látható az arcfelimerés kezelése.
            <programlisting language="c++"><![CDATA[
void SamuCam::run()
{

    cv::CascadeClassifier faceClassifier;

    std::string faceXML = "lbpcascade_frontalface.xml"; // https://github.com/Itseez/opencv/tree/master/data/lbpcascades

    if ( !faceClassifier.load ( faceXML ) )
    {
        qDebug() << "error: cannot found" << faceXML.c_str();
        return;
    }

    cv::Mat frame;

    while ( videoCapture.isOpened() )
    {

        QThread::msleep ( 50 );
        while ( videoCapture.read ( frame ) )
        {

            if ( !frame.empty() )
            {

                cv::resize ( frame, frame, cv::Size ( 176, 144 ), 0, 0, cv::INTER_CUBIC );

                std::vector<cv::Rect> faces;
                cv::Mat grayFrame;

                cv::cvtColor ( frame, grayFrame, cv::COLOR_BGR2GRAY );
                cv::equalizeHist ( grayFrame, grayFrame );

                faceClassifier.detectMultiScale ( grayFrame, faces, 1.1, 4, 0, cv::Size ( 60, 60 ) );

                if ( faces.size() > 0 )
                {

                    cv::Mat onlyFace = frame ( faces[0] ).clone();

                    QImage* face = new QImage ( onlyFace.data,
                                                onlyFace.cols,
                                                onlyFace.rows,
                                                onlyFace.step,
                                                QImage::Format_RGB888 );

                    cv::Point x ( faces[0].x-1, faces[0].y-1 );
                    cv::Point y ( faces[0].x + faces[0].width+2, faces[0].y + faces[0].height+2 );
                    cv::rectangle ( frame, x, y, cv::Scalar ( 240, 230, 200 ) );


                    emit  faceChanged ( face );
                }

                QImage*  webcam = new QImage ( frame.data,
                                                frame.cols,
                                                frame.rows,
                                                frame.step,
                                                QImage::Format_RGB888 );

                emit  webcamChanged ( webcam );

            }

            QThread::msleep ( 80 );

        }

        if ( ! videoCapture.isOpened() )
        {
            openVideoStream();
        }

    }

}]]>
            </programlisting>
            Ebből a kódrészetből a <function>while</function> ciklus tartalma a lényeg. Ezt nézzük át most egy kicsit részletesebben. Elsőnek szükségünk van egy 
            <classname>cv::Mat</classname> osztályú objektumra. Ennek segítségével az egyes képkockákat egy többdimenziós tömbben tudjuk tárolni. 
            A <function>while</function> ciklus törzse addig ismétlődik, ameddig a kamera meg van nyitva. Beolvassuk a <varname>frame</varname> tömb tartalmát, 
            ha üres, akkor pedig beolvasunk a kamera képéről egy arcot. Ehhez a <function>detectMultiScale</function> függvényt használjuk, mely különböző méretű
            objektumokat, jelen esetben arcokat képes felismerni, és egy vektorba négyzetek formájában adja vissza az eredményt. Majd ebből a vektorból 
            kiolvassuk az első felismert ojektumot, azt képpé alakítjuk, és jelezzük, hogy megváltozott a kamera képe. Az <function>emit</function> utasításról a 
            következő feladatban lesz szó.
            <figure>
                <title>Program működés közben</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/SamuCam/program.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>                    
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    <section>
        <title>BrainB</title> <!-- A számítás osztály van összekapcsolva az ablakkal -->
        <para>
            Mutassuk be a Qt slot-signal mechanizmust ebben a projektben: <link xlink:href="https://github.com/nbatfai/esporttalent-search">https://github.com/nbatfai/esporttalent-search</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/BrainB">https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/BrainB</link>               
        </para>
        <caution>
            <title>Szükséges csomag</title>
            <para>
                <programlisting>sudo apt install libopencv-dev</programlisting>
            </para>
        </caution>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Az könyv első részében már volt szó a BrainB-ről. Ez a program a karakter-elvesztés problémakörét vizsgálja. Ha játszol League of Legends-el, biztos
            voltál már olyan helyzetben, hogy túl sok karakter volt egy helyen, és nem találtad a sajátodat. Pontosan ezt szimulálja a program is. Rajta kell tartanod az
            egeret <varname>Samu Entropy</varname>-n, eközben folyamatosan nő a négyzetek száma a képernyőn. Ha kilépsz a programból, akkor kapsz egy értékelést az elért 
            eredményediről.
            <figure>
                <title>BrainB</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/BrainB/program.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
        </figure>                    
        </para>
        <para>
            Most, hogy felelevenítettük a BrainB működését, foglalkozzunk a feladat témájával. A Qt egy alkalmazás-keretrendszer, mely lehetővé teszi GUI-s alkalmazások készítését,
            de hagyományos parancssoros alkalmazásokat is fejleszthetünk vele. A C++ programnyelv mellett akár Python nyelven is készíthetünk alkalmazásokat Qt segítségével. Nagy 
            előnye, hogy a Qt segítségével keresztplatformos alkalmazásokat készíthetünk. 
        </para>
        <para>
            Grafikus felületek fejlesztésekor elvárás, hogy egyes elemeken végrehajtott interakciók, más elemeken fejtsék ki hatásukat. Vegyük példának azt, hogyha megnyomunk egy 
            gombot, annak hatására jelenjen meg egy új abalak. Ennek érdekében a Qt egy új mechanizmust vezetett be, mely a signal-slot. Visszatérve a példához, ha megnyomjuk a gombot, az egy
            signalt vált ki, melynek hatására a vele összekapcsolt objektum egyik slotját hajtja végre.
            Nézzük meg, hogy ez a példa hogyan is nézne ki Qt-ban:
            <programlisting language="c++"><![CDATA[
connect(button, &QPushButton::clicked, window, &QWidget::createNewWindow);]]>
            </programlisting>
            Ha megnézed a BrainB program forrását, akkor ez egy kicsit más szintaxissal fog szerepelni. Tehát emeljünk most ki egy példát a BrainB-ből.
            <programlisting language="c++"><![CDATA[
connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
    this, SLOT ( updateHeroes ( QImage, int, int ) ) ); ]]>
            </programlisting>
            Utóbbiban explicit módon szerepel, hogy melyik a signal, és melyik a slot. Fontos megjegyezni, hogy ez a régi szintaxis, ha Qt-ban fejlesztenél a 
            másikat használd inkább. 
        </para>
        <para>
            Mielőtt rátérnénk arra, hogy mi a szerepe a signal-slot mechanizmusnak a BrainB-ben, imserkedjünk meg egy kicsit jobban vele. A signal-ok olyan 
            függvényeknek tekinthetőek, amik nem rendelkeznek definícióval, csak deklarációval. Nem lehet visszatérési értéke, viszont lehetnek paramétereik.
            Fontos tulajdonságuk a signal-oknak, hogy nem lehet őket hagyományos módon meghívni, ehhez <function>emit</function> makrót kell használni.
            <programlisting>
                emit mysignal(value);
            </programlisting>
            A slot-ok ezzel szemben teljes mértékben a függvényekre hasonlítanak, meg lehet őket hívni, mint a függvényeket, van definíciójuk, lehetnek paramétereik, viszont ezeknek
            sem lehet visszatérési értékük. Fontos, hogy csak olyan signal-slot párokat tudunk összekötni, melyek kompatiblisek egymással. Ez alatt azt kell érteni, hogyha a signal
            paramétere 2 db egész, akkor a slot-nak vagy nem szabad lennie paraméterének, vagy pedig azonos paramétereket kell kérnie. Ez azért fontos, mert a signal paramétereinek 
            értékei át tudnak adódni a slot-nak. A régebbi szintaxisban a paraméterlistát mindig ki kell írni, ez az újban már nem szükséges. 
        </para>
        <para>
            A Qt által biztosított osztályok mind tartalmaznak beépített signal-okat és slot-okat. Ha szeretnénk egyedi megoldásokat is használni, akkor 
            készíthetünk leszármazott osztályokat. Ha olyan osztályt akarunk készíteni, ami képes kezelni a signal-slot mechanizmust, akkor mindenképpen 
            tartalmaznia kell az osztálynak a <function>Q_OBJECT</function> makrót. Egy pontosítás még szükséges, ugyanis csak akkor lehet ezt a makrót
            használni, ha az osztályunk őse a <classname>QObject</classname> osztály, vagy a ős osztályunk leszármazottja a <classname>QObject</classname>
            osztálynak. A Qt összes saját osztálya leszármazottja ennek az osztálynak, tehát csak az általunk készített osztályokkal kell figyeelni erre a 
            kitételre.
        </para>
        <para>
            Egy érdekességet még említsünk meg, mielőtt rátérünk a BrainB-re. A programunk túl sok signal-slot párt tartalmaz, jelentős lassulás eredményezhet, 
            szóval érdemes csak szükséges esetben használni. Egy másik hátránya ennek a megoldásnak, hogy a C++ nyelvben gyakran használt sablon osztályokat nem támogatja.
            Ha a programunk fejlesztése során szükségünk lenne sablon osztályokra, akkor érdemes megismekedni a Woboq GmbH áltral fejlesztett Verdigris 
            projektre (<link xlink:href="https://github.com/woboq/verdigris">https://github.com/woboq/verdigris</link>). A templatelt osztályok támogatása mellett 
            gyorsabb fordítási időt érhetünk el, és programunk működése is egy kicsit gördülékenyebb lesz. A fordítási idő azért gyorsul, mert a Qt saját mechanizmusát 
            a Meta-Object Compiler(moc) biztosítja, mely fordításkor külön állományokat hoz létre, ha valamelyik header a <function>Q_OBJECT</function> makrót tartalmazza,
            erre a Verdigris-ben használt megoldásban nincs szükség.
        </para>
        <para>
            Akkor lássuk, hogy mire használjuk a signa-slot mechanizmust a BrainB-ben.
            <programlisting language="c++"><![CDATA[
connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
    this, SLOT ( updateHeroes ( QImage, int, int ) ) );

connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
    this, SLOT ( endAndStats ( int ) ) );]]>
            </programlisting>
            A BrainB-ben két fő osztályunk van, az egyik az ablak, és az abban lévő objektumok mejelenítéséért felel, még a számításokért. Az első <function>connect</function>
            függvénynél azt láthatjuk, hogy ha megváltozik a hődök száma/pozíciója, akkor a <varname>brainBThread</varname> objektum <function>heroesChanged</function> signal-ja 
            kiváltódik, ehhez hozzákötjük az ablakunkat kezelő osztály <function>updateHeroes</function> slot-ját. Ezzel érjük el azt, hoyg minden a számítási osztály által végzett módosulás
            láthatóvá váljon a képernyőn. A másik <function>connect</function> pedig azt teszi lehetővé, hogyha  leállítjuk a programot, akkor az záródjon be az ablak. 
        </para>
    </section>        

    <section>
        <title>OSM térképre rajzolása</title> <!-- Ebből éredmes az androidosat választani -->
        <para>
            Debrecen térképre dobjunk rá cuccokat, ennek mintájára, ahol én az országba helyeztem el a DEAC
            hekkereket: <link xlink:href="https://www.twitch.tv/videos/182262537">https://www.twitch.tv/videos/182262537</link> (de az OOCWC Java Swinges
            megjelenítőjéből: <link xlink:href="https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin">https://github.com/nbatfai/robocar-emulator/tree/master/justine/rcwin</link> is
            kiindulhatsz, mondjuk az komplexebb, mert ott időfejlődés is van...)
        </para>
        <para>
            Alternatívaként készíthetsz egy GoogleMaps alapú Androidos „GPS trackert”, 2007 óta csinálok ilyen példát:
            <link xlink:href="https://youtu.be/QStgBZ6JfAU">https://youtu.be/QStgBZ6JfAU</link> az aktuális a Bátfai Haxor Stream keretében:
            <link xlink:href="https://bhaxor.blog.hu/2018/09/19/nandigps_ismerkedes_a_gps-el">https://bhaxor.blog.hu/2018/09/19/nandigps_ismerkedes_a_gps-el</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/GoogleMapsLocationTracker">https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/GoogleMapsLocationTracker</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Ebben a feladatban a GPS trackert készítjük el, melyhez szükségünk lesz az Android Studio-ra. Ahhoz, hogy használhassuk a Google Maps API-t, ahhoz regisztálnunk kell
            a következő oldalon <link xlink:href="https://cloud.google.com/maps-platform/?_ga=2.252747598.631078138.1572438536-1885212309.1570903858#get-started">https://cloud.google.com/maps-platform/?_ga=2.252747598.631078138.1572438536-1885212309.1570903858#get-started</link>.
            Ha sikerült megszereznünk az API kulcsot, akkor létre kell hoznunk egy új projektet az Android Studio-ban. Az Acvtivity-k közül válasszuk a Google Maps Activity-t. HA megnyílik a 
            projekt, egy látni fogjuk a <filename>google_maps_api.xml</filename> fájl tartalmát.
            <programlisting><![CDATA[
                <string name="google_maps_key" templateMergeStrategy="preserve" translatable="false">YOUR_KEY_HERE</string>]]>
            </programlisting>
            Ebbe a sorba kell beillesztenünk a Google-től kapott API kulcsot. Ezután pedig kezdhetjük az érdemi munkát. Alapértelmezetten a program arra képes, hoyg megnyisson egy 
            tréképet, és azon megjelölje Sydney-t. A mi feladatunk az, hogy a saját helyünket adja meg a program induláskor, majd pedig kövessen minket.
            <programlisting language="java">
public class MapsActivity extends FragmentActivity implements OnMapReadyCallback, LocationListener {
    ...
}
            </programlisting>
            Első lépséként át kell alakítanunk az osztályunkat, hogy implementálja a <classname>LocationListener</classname> interfészt. Erre azért lesz szükség, mert
            a pozíciónk változását ezen keresztül fogjuk tudni követni. Ahhoz, hogy biztosan működjön a saját pozició meghatározása, ellenőrizni kell, hogy a program hozzáfér-e a 
            helyadatokhoz, és ha nem, akkor a felhasználó engedélyét kerjük. Ezt valósítja meg a <function>checkPermission()</function> függvény,
            <programlisting language="java"><![CDATA[
public void CheckPermission() {
    if (ContextCompat.checkSelfPermission(getApplicationContext(),
        android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &&
        ActivityCompat.checkSelfPermission(getApplicationContext(), 
        android.Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED){
        ActivityCompat.requestPermissions(this, new String[]{android.Manifest.permission.ACCESS_FINE_LOCATION, 
                                                    android.Manifest.permission.ACCESS_COARSE_LOCATION}, 101);
    }
}]]>            
            </programlisting>
            Majd definiáljuk a <classname>FragmentActivity</classname> egy virtuális függvényét, az <function>onResume</function>.
            <programlisting language="java"><![CDATA[
@Override
public void onResume() {
    super.onResume();
    getLocation();
}]]>            
            </programlisting>
            Ez a függvény a program megnyitásakor hívódik meg. Tehát ennek kell meghívnia a <function>getLocation()</function> metódust, mellyel
            megkapjuk az aktuális pozicíónkat.
            <programlisting language="java"><![CDATA[
public void getLocation() {
    try {
        mlocationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        mlocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 50, 1f, this);
//           mlocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 50, 1f, this);
    } catch (SecurityException e) {
        e.printStackTrace();
    }
}]]>            
            </programlisting>
            A <classname>LocationManager</classname> osztály felel a helyadatok kezeléséért. Ezt úgy érjük el, hogy a <function>getSystemService</function> függvénnyel 
            visszaadjuk a helyadatok kezeléséért felelős szolgáltatás kezelőjét. Majd a <function>requestLocationUpdates</function> függvénnyel pedig megadjuk, hogy 
            melyik helykiszolgálót szeretnénk használni, milyen időközönként kérjünk frissítést, milyen távolságonként, és végül megadjuk a saját osztályunkat, melynek
            <function>onLocationChanged</function> függvénye fog meghívódni, minden egyes frissítéskor. Helykiszolgáló, vagyis az, amin keresztül hozzáférünk a helyadatokhoz,
            jelen esetben az Internet, de használhatnánk a GPS-t is. A jelen paraméterek szerint 50 ezredmásodpercenként kérünk frissítést, vagy 1 méterenként. Lássuk, hogy a 
            frissítés során mi történik.
            <programlisting language="java"><![CDATA[
@Override
public void onLocationChanged(@org.jetbrains.annotations.NotNull Location location) {
    LatLng mylocation = new LatLng(location.getLatitude(), location.getLongitude());
    if(firstCall){
        marker = mMap.addMarker(new MarkerOptions().position(mylocation).title("You are in " + getLocationName(location)));
        marker.showInfoWindow();
        firstCall = false;
    }else {
        mMap.addPolyline(new PolylineOptions()
                .add(marker.getPosition(), mylocation)
                .width(5)
                .color(Color.BLUE));
        marker.remove();
        marker = mMap.addMarker(new MarkerOptions().position(mylocation).title("You are in " + getLocationName(location)));
        marker.showInfoWindow();
    }
    mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(mylocation, 17f));

}]]>
            </programlisting>
            Az <function>onLocationChanged</function> metódus a <classname>LocationListener</classname> interfész egy virtuális függvénye. Ez pereméteréül mindig az 
            aktuális pozíciót kapja. A <classname>LatLng</classname> osztály segítségével eltároljuk a hosszúsági és szélességi adatokat a <varname>mylocation</varname>
            változóban. Ha először hívódik meg a függvény, akkor csak egy jelet rakunk a térképen az aktuális helyünkre. Viszont ha nem, akkor húzunk egy vonalat a 
            a korábban lerakott jel és az új pozíció között, majd töröljük a korábbi jelet, és rakunk egyet az új helyre. Ezzel lényegében azt érjük el, hogy a 
            csík mutatja az általunk megtett utat, a jel pedig mutatja a pozíciónkat. A jel felett egy buborékban pedig az jelenik meg, hoyg melyik 
            településen vagyunk éppen. Ehhez a <function>getLocationName</function> függvényre van szükségünk.
            <programlisting language="java"><![CDATA[
public String getLocationName(Location location){
    Geocoder gcd = new Geocoder(this, Locale.getDefault());
    try {
        List<Address> addresses = gcd.getFromLocation(location.getLatitude(), location.getLongitude(), 1);
        if (addresses.size() > 0) {
            return addresses.get(0).getLocality();
        }else return "error";
    }catch(Exception e) {
        throw new RuntimeException(e);
    }
}]]>               
            </programlisting>
            A <classname>Geocoder</classname> osztály a geokódolást és a fordított geokódolást teszi lehetővé. Számunkra az utóbbi az érdekes, amikor a 
            heyadatokból megadjuk a település nevét. Ehhez elsőnek létrehozzuk a <varname>gcd</varname> objetumot. Majd a <function>getFromLocation</function>
            függvény segítségével kinyerjük az adott területhez tartozó címtalálatokat. Az utolsó paraméter azt határozza meg, hogy maximum hány találatot szeretnénk 
            visszakapni. Az kapott <classname>Address</classname> típusú objetumokat egy listában tároljuk. Majd ellenőrizzük, hogy van-e elem a listában, ha van, akkor 
            pedig visszaadjuk a címből a település nevét a <function>getLocality</function> függvény segítségével. 
        </para>
        <para>
            A lényegi része a feladatnak ezzel kész, néhány függvényt még definiálni kell a <classname>LocationListener</classname> interfészből, de ezekről már
            nem beszélünk részletesen, a linkelt forrásban látható.
        </para>
        <para>
            Végezetül lássuk, hogyan működik a program.
            <figure>
                    <title>GoogleTracker</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="../../attention_raising/Source/GoogleMapsLocationTracker/googletracker.png" format="PNG"/>
                            </imageobject>
                        </mediaobject>
            </figure>  
        </para>
    </section>        

</chapter>                
