<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Encoding</title>
        <para>
            Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a
            fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket!
        </para>
        <para>
            <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Mandelbrot/Zoom_java">https://github.com/fupn26/BHAX/tree/master/attention_raising/Mandelbrot/Zoom_java</link>              
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A könyv előző részében már megbeszélt programról lesz szó, illetve annak a fordításáról. Az alkalmazás lehetővé teszi, hogy 
            a Mandelbrot halmazt tetszőleges mértékben nagyítsuk. Lényegében mindig egy újabb Mandelbrot halmaz rajzolódott ki. Lehetett 
            pontosítani a számításokon is, sőt még képernyőképet is készíthettünk. De most azzal fogunk megismerkedni, hogy Java nyelv milyen módon
            teszi lehetővé, hogy ékezetes betűket használjunk a forrásban.
        </para>
        <para>
            Java nyelv különlegessége, hogy forráskódban támogatja az Unicode karakterkódolást, ellentétben a C/C++-al, ahol 
            csak ASCII karaktereket használhattunk. Viszont fontos megjegyezni, hogy az, hogy támogatja, nem azt jelenti, hogy 
            egyből lefordul a kód. Legalábbis nem minden esetben. Például Linux operációs rendszereken nem feltétlen probléma, de 
            Windows platfromon, már hibákba ütközhetünk. 
        </para>
        <para>
            A megoldás a problémára a Javac <function>-encoding</function> kapcsolója. Ezután megadhatjuk a kívánt karakterkódolást, 
            és lefordul a programunk. 
            <programlisting>
                javac -encoding utf8 MandelbrotHalmazNagyító
            </programlisting>
        </para>
    </section>        

    <section>
        <title>OOCWC lexer</title>
        <para>
            Izzítsuk be az OOCWC-t és vázoljuk a <link xlink:href="https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll">https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll</link>
            lexert és kapcsolását a programunk OO
            struktúrájába!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A korábbi részben már taglaltuk, hogy mi is az a lexer. A lexer feladata, hogy tokenizálja a bemeneteket, és
            ez alapján elemezzük azt. Természetesen ezt le lehetne programozni saját magunknak is, de mivel létezik a 
            Lex, ezért erre nincs szükség. A Lex egy program, amely lexikális elemzőt generál. Beolvassa a bemenetet, és 
            elkészíti a lexikális elemzőt, majd pedig legenerálja a C++ forrást. 
        </para>
        <para>
                Az alap struktúra a következő:
                <programlisting><![CDATA[
                    {definíciók}
                    %%
                    {szabályok}
                    %%
                    {felhasználói utasítások} 
                    ]]>
                </programlisting>
            </para>
            <para>
            Ez alapján nézzük végig a <filename>carlexer.ll</filename>
            <programlisting><![CDATA[
                %option c++
                %option noyywrap
            ]]></programlisting>
            A forrás elsőrésze azt adja meg, hogy c++ forrást szeretnénk generálni, 
            és nincs szükségünk az <function>yywrap()</function> függvényre. Az 
            <function>yywrap()</function> feladata az lenne, hogy amikor az <function>yylex()</function>
            végére ér a bemenetnek, akkor meghívja, és ha 1-et ad vissza, akkor nincs már
            több bemenet, 0 esetén pedig tovább olvassa a bemenetet amire az <function>yyin</function>
            mutat. Mivel a <function>yywarp()</function> függvény definícióját nem adja meg
            a Lex program a kimeneti C++ fájlban, ezt a programozónak kell elkészítenie.
            <programlisting><![CDATA[
                %{
                    #define YY_DECL int justine::robocar::CarLexer::yylex()
                    #include "carlexer.hpp"
                    #include <cstdio>
                    #include <limits>
                %}
            ]]></programlisting>
            Az opciók megadása után inclúdálhatjuk a szükséges header állomámnyokat,
            deklarálhatjuk a szükséges változókat, vagy macro-kat hozhatunk létre.
            <programlisting><![CDATA[
                INIT	"<init"
                INITG	"<init guided"
                WS	[ \t]*
                WORD	[^-:\n \t()]{2,}
                INT	[0123456789]+
                FLOAT	[-.0123456789]+
                ROUTE	"<route"
                CAR	"<car"
                POS	"<pos"
                GANGSTERS	"<gangsters"
                STAT	"<stat"
                DISP	"<disp>"
            ]]></programlisting>
            A következő lépés az egyes lexer-hez szükséges változók megadása. Lényegében megadunk
            egy nevet és ehhez hoozákapcsolunk egy stringet, így után a nevet tudjuk használni a 
            szabályok meghatározása során. Tehát, ahogy látható, az <function>INIT</function> esetén 
            a <![CDATA["<init"]]> sztnget olvasunk be. A <function>WS</function> a whitespace-t jelenti,
            és azért van ott a csillag, mert bármennyi lehet belőle, akár 0 is. A <function>WORD</function>
            egy kicsit érdekesebb reguláris kifejezés. Ez olyan bemeneteket jelent, amik nem
            <![CDATA[-,:,\n, \t,(,)]]> karakterekből állnak, és legalább 2 elemből. A többi 
            pedig értelemszerű, szóval azokra most nem térünk ki külön.
            <programlisting><![CDATA[
            %% 
            {DISP}					{
                                m_cmd = 0;
                                }
            {POS}{WS}{INT}{WS}{INT}{WS}{INT}	{
                                std::sscanf(yytext, "<pos %d %u %u", &m_id, &from, &to);
                                m_cmd = 10001;
                                }
            {CAR}{WS}{INT}				{
                                std::sscanf(yytext, "<car %d", &m_id);
                                m_cmd = 1001;
                                }
            {STAT}{WS}{INT}				{
                                std::sscanf(yytext, "<stat %d", &m_id);
                                m_cmd = 1003;
                                }
            {GANGSTERS}{WS}{INT}			{
                                std::sscanf(yytext, "<gangsters %d", &m_id);
                                m_cmd = 1002;
                                }
            {ROUTE}{WS}{INT}{WS}{INT}({WS}{INT})*	{
                            int size{0};
                            int ss{0};
                            int sn{0};				  
                            
                            std::sscanf(yytext, "<route %d %d%n", &size, &m_id, &sn);
                            ss += sn;
                            for(int i{0}; i<size; ++i)
                            {
                                unsigned int u{0u};
                                std::sscanf(yytext+ss, "%u%n", &u, &sn);
                                route.push_back(u);
                                ss += sn; 				    
                            }
                            m_cmd = 101;
                            }
            {INIT}{WS}{WORD}{WS}("c"|"g")	{
                            std::sscanf(yytext, "<init %s %c>", name, &role);
                            num = 1;
                            m_cmd = 0;
                            }
            {INIT}{WS}{WORD}{WS}{INT}{WS}("c"|"g")	{
                            std::sscanf(yytext, "<init %s %d %c>", name, &num, &role);
                            if(num >200)
                            {
                                m_errnumber = 1;
                                num = 200;
                            }
                            m_cmd = 1;
                            }				
            {INITG}{WS}{WORD}{WS}("c"|"g")	{
                            std::sscanf(yytext, "<init guided %s %c>", name, &role);
                            num = 1;
                            m_guided = true;
                            m_cmd = 3;
                            }
            {INITG}{WS}{WORD}{WS}{INT}{WS}("c"|"g")	{				  
                            std::sscanf(yytext, "<init guided %s %d %c>", name, &num, &role);
                            if(num >200)
                            {
                                m_errnumber = 1;
                                num = 200;
                            }
                            m_guided = true;
                            m_cmd = 2;
                            }								
            .				{;}
            %%
            ]]></programlisting>
            A szabályok részben pedig megadjuk, hogy az egyes bemenetek szerint mi legyen az egyes változók
            értéke. Ehhez a <function>sscanf</function>-et használjuk, aminek az első paramétere a bemenet, 
            majd annak a formátuma, és végül az egyes változók, amikbe "beleírjuk" az értékeket.
            <programlisting>
                int yyFlexLexer::yylex(){return -1;}
            </programlisting>
            Végezetül definiáljuk az <function>yylex()</function> függvényt. Ebből a <filename>carlexer.ll</filename>
            fájlból pedig a <function>lex</function> parancs legenerálja a forrást.
        </para>
        <para>
            <emphasis role="strong">C++ forrás generálása</emphasis>
            <programlisting>
                lex carlexer.ll
            </programlisting>
        </para>
    </section>        
        
    <section>
        <title>
            <emphasis role="cadiumgreen">l334d1c45</emphasis>
        </title>
        <para>
            Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű
            helyettesítést: <link xlink:href="https://simple.wikipedia.org/wiki/Leet">https://simple.wikipedia.org/wiki/Leet</link>
            (Ha ez első részben nem tetted meg, akkor írasd
            ki és magyarázd meg a használt struktúratömb memóriafoglalását!)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/LeetCipher">https://github.com/fupn26/BHAX/tree/master/attention_raising/Source/LeetCipher</link>               
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Mielőtt elkészeténk a feladatban megadott osztályt, vessünk egy pillantást a már korábban
            taglalt <filename>l337d1c7.l</filename> forrásra, az abban lévő <function>cipher</function>
            struktúrára.
            <programlisting>
                struct cipher {
                    char c;
                    char *leet[4];
                    }
            </programlisting>
            Ha a <function>sizeof</function> függvénnyel kiíratjuk a méretét, akkor azt kapjuk, hogy 
            40 bájt. A <function>leet</function> kétdimenziós tömb mérete 32 bájt, mivel a
            <function>char*</function> 8 bájt, és a tömb 4-szer ennyi helyet foglalt le. A
            <function>char</function> mérete pedig 1 bájt. Akkor hol a hiba? A megoldás a 
            válaszra a <emphasis role="strong">padding</emphasis>. A padding lényege, hogy a 
            fordító a címzési hibák elkerülése érdekében extra területet foglalhat az egyes tagokhoz.
            Ezt nem tudjuk szabályozni, a fordító dönt. De a szabály az, hogy ha egy tag előtt vagy mögött vagy a
            struktúra legvégén deklarálva van egy nagyobb tag, akkor mérete a nagyobb tagéval lesz egyenlő. 
            Ezért érdemes méretük alapján csökkenő sorrendben rendezni a struktúra elemeit, azok mérete szerint.
            Van egy megoldás a padding teljes megszüntetésére, ez pedig a <function>#pragma pack(1)</function>.
            Ennek segítségével már a várt 33, a struktúra mérete.
            <figure>
                    <title>Pragma nélkül</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="../../attention_raising/Source/l334d1c45/no_pragma.png" format="PNG"/>
                            </imageobject>
                        </mediaobject>
            </figure>
            <figure>
                    <title>Pragma nélkül</title>
                        <mediaobject>
                            <imageobject>
                                <imagedata fileref="../../attention_raising/Source/l334d1c45/with_pragma.png" format="PNG"/>
                            </imageobject>
                        </mediaobject>
            </figure>
        </para>
        <para>
            Most, hogy tisztáztuk a korábbi feladat struktúrájának méretét, kezdjük el az új programot.
            Továbbra is ugyanazt fogja csinálni a program, csak kap egy grafikus felületet a Qt segítségével, és nem fogjuk most
            használni a Lex programot.
            <figure>
                <title>Pragma nélkül</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/LeetCipher/leetcipher.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Korábban már volt szó a Qt eszköztáráról, ezért most arra részletesebben nem térnék ki. Lássuk elsőnek a 
            <function>Cipher</function> osztályt.
            <programlisting language="c++"><![CDATA[
                #include <QVector>
                #include <QRandomGenerator>
                
                class Cipher
                {
                public:
                    Cipher();
                    QString get_result();
                    void encryption(QString);
                
                private:
                    struct m_cipher{
                        char c;
                        char const *leet[4];
                    };
                
                    QVector<struct m_cipher> m_vector;
                
                    QString m_result;
                };]]>
            </programlisting>
            Az korábbi c forrásban tömböt használtunk az egyes karakterekhez tartozó konverziókhoz, ezt most vektorra cseréljük, <function>QVector</function>-ra.
            A csere oka az volt, hogy egy fejletebb adatstruktúrát használjunk, aminek például van olyan függvénye, amely megadja az elemei számát. A random számok
            generálását pedig a <function>QRandomGenerator</function> osztályra bízzuk. Az osztállyal megegyező nevű függvények a konstruktorok, azokról később beszélünk. 
            A <function>get_result()</function> függvény feladata, hogy a <function>m_result</function> privát tag értékéhez hozzáférést biztosítson.
            <programlisting language="c++"><![CDATA[
                QString Cipher::get_result(){
                    return m_result;
                }
            ]]></programlisting>
            Magát a szöveg kódolását a <function>encryption()</function> függvény végzi, melynek definíciója a következő:
            <programlisting language="c++"><![CDATA[
                void Cipher::encryption(QString input){
                    m_result.clear();
                    for (int x = 0; x < input.length(); ++x){
                        int found = 0;
                        for(int i=0; i<m_vector.length(); ++i)
                        {
                
                            if(m_vector[i].c == input[x].toLower())
                            {
                
                                int r = static_cast<int>(QRandomGenerator::global()->generate()%4);
                
                                m_result.append(m_vector[i].leet[r]);
                
                                found = 1;
                                break;
                            }
                
                        }
                
                        if(!found)
                            m_result.append(input[x]);
                    }
                }
            ]]></programlisting>
            Alapjában véve hasonlít a korábbi megoldásra, csak kisebb módosítások lettek rajta végezve. Az <function>m_result</function>-ot minden 
            híváskor ürítjük, hogy ne legyenek benne a korábbi fordításból származó eredmények. Majd végig megyünk a bemeneten karakterenként, és
            ha van olyan karakter,a mit tudunk helyettesíteni, akkor random kiválasztunk egyet, ha nem, akkor pedig az eredetit rakjuk be az <function>m_result</function>
            sztingbe. A random számot a <function>QRandomGenerator::global()->generate()</function> függvénnyel generálunk. De mivel nekünk csak 4 elem van a helyettesíthető
            elemek között, ezért a random számot maradéksan osztjuk 4-gyel. 
        </para>
    </section>        

    <section>
        <title>
            <emphasis role="cadiumgreen">Full screen</emphasis>
        </title>
        <para>
            Készítsünk egy teljes képernyős Java programot!
            Tipp: <link xlink:href="https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat/ch03.html#labirintus_jatek">
            https://www.tankonyvtar.hu/en/tartalom/tkt/javat-tanitok-javat
                                    /ch03.html#labirintus_jatek</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            A feladat során egy Snake-t készítünk el, amely teljesképernyő módban jelenik meg. A program alapját a 
            <link xlink:href="http://zetcode.com/tutorials/javagamestutorial/snake/">
                http://zetcode.com/tutorials/javagamestutorial/snake/</link>. Ezen kell néhány módosítást eszközölni, és 
                készen is vagyunk. 
        </para>
        <para>
            Maga a Snake játék lényege, hogy a nyílbilentyűkkel irányítjuk a kígyót. Eközben random helyeken almák jelennek meg, amiket 
            ha felveszünk, nagyobb lesz a kígyónk. A nehézség abban rejlik, hogy benne kall maradni a keretben, és nem szabad önmagába mennie a kígyónak.
        </para>
        <para>
            A csomag 2 forrásból áll: <filename>Snake.java</filename> és <filename>Board.java</filename>. Elsőnek nézzük végig a 
            Board.java forrást.
            <programlisting language="java"><![CDATA[
                public class Board extends JPanel implements ActionListener{
    
                    private final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
                
                    private final int B_WIDTH = (int)screenSize.getWidth();//300;
                    private final int B_HEIGHT = (int)screenSize.getHeight();//300;
                    private final int DOT_SIZE = 10;
                    private final int ALL_DOTS = 900;
                    private final int RAND_POS = 29;
                    private final int DELAY = 140;
                
                    private final int x[] = new int[ALL_DOTS];
                    private final int y[] = new int[ALL_DOTS];
                
                    private int dots;
                    private int apple_x;
                    private int apple_y;
                
                    private boolean leftDirection = false;
                    private boolean rightDirection = true;
                    private boolean upDirection = false;
                    private boolean downDirection = false;
                    private boolean inGame = true;
                
                    private Timer timer;
                    private Image ball;
                    private Image apple;
                    private Image head;
            ]]></programlisting>
            Ahogy látható, a <function>JPanel</function> osztály az őse, és implementálja a <function>ActionListener</function> interfészt.
            Az első módosítás itt történik meg, létrehozunk egy <function>Dimension</function> típusú objektumot. Melynek az értéke a 
            kijelző mérete lesz. Mind a <function>Dimension</function>, mind a <function>ToolKit</function> osztály a Java AWT API része.
            Ha megvan a méret, akkor megadjuk a monitorunk szélességét és magásságát a <function>B_WIDTH</function> és <function>B_HEIGHT</function>
            konstansoknak. Ezen kívül megadjuk a pontok (amiből a kígyó épül fel) méretét, hogy mennyi lehet belőle, a késleltetést, és még sorolatnánk.
            <programlisting language="java"><![CDATA[
                private void initBoard() {

                    addKeyListener(new TAdapter());
                    setBackground(Color.black);
                    setFocusable(true);
            
                    setPreferredSize(new Dimension(B_WIDTH, B_HEIGHT));
                    loadImages();
                    initGame();
                }
            ]]></programlisting>
            Az <function>initBoard()</function> függvény segítségével iniciílizáljuk a táblát. A mi szempontunkból a <function>setPreferredSize()</function> függvény a fontos.
            Ebben adjuk meg a monitorunk felbontását. Beállítjuk a háttér színét feketére a <function>setBackground</function> függvénnyel. És hozzáadunk egy billentyűkezelőt az 
            <function>addKexListener</function> segítségével. Ehhez létrehozunk egy privát osztályt, a <function>TAdapter</function>-t. Ennek implementációja a következő:
            <programlisting language="java"><![CDATA[
                private class TAdapter extends KeyAdapter {

                    @Override
                    public void keyPressed(KeyEvent e) {
            
                        int key = e.getKeyCode();
            
                        if ((key == KeyEvent.VK_LEFT) && (!rightDirection)) {
                            leftDirection = true;
                            upDirection = false;
                            downDirection = false;
                        }
            
                        if ((key == KeyEvent.VK_RIGHT) && (!leftDirection)) {
                            rightDirection = true;
                            upDirection = false;
                            downDirection = false;
                        }
            
                        if ((key == KeyEvent.VK_UP) && (!downDirection)) {
                            upDirection = true;
                            rightDirection = false;
                            leftDirection = false;
                        }
            
                        if ((key == KeyEvent.VK_DOWN) && (!upDirection)) {
                            downDirection = true;
                            rightDirection = false;
                            leftDirection = false;
                        }
                        if(e.getKeyChar() == 'q'){
                            System.exit(0);
                        }
                    }
                }
            ]]></programlisting>
            Ez az osztály kezeli a billentyűlenyomásokat. Az eredeti verzió csak a nyilakat kezelte, de mivel teljesképernyős a program, ezért kellett
            egy új billentyű, amivel kilépünk. Ehhez a "q" bilentyűt választottuk.
            <programlisting>
                private void loadImages() {

                    ImageIcon iid = new ImageIcon("src/images/dot.png");
                    ball = iid.getImage();
            
                    ImageIcon iia = new ImageIcon("src/images/apple.png");
                    apple = iia.getImage();
            
                    ImageIcon iih = new ImageIcon("src/images/head.png");
                    head = iih.getImage();
                }
            </programlisting>
            Mivel a képernyőn képeket mozgatunk, ezért szükség van a képek betöltésére is, ezt végzi el a <function>loadImages</function> függvény.
            <programlisting><![CDATA[
                private void initGame() {

                    dots = 3;
            
                    for (int z = 0; z < dots; z++) {
                        x[z] = 50 - z * 10;
                        y[z] = 50;
                    }
                    
                    locateApple();
            
                    timer = new Timer(DELAY, this);
                    timer.start();
                }
            ]]></programlisting>
            A játék alapját a <function>initGame</function> inicializálja. Ebben benne van, hogy a kezdeti hossza a kígyónak 3. Elhelyezzük az első almát a 
            és a kígyót a képernyőn. Végül elindítjuk az időzítőt, hogy tudjuk, mennyit kell várni a kijelző frissítésével.
            <programlisting language="java"><![CDATA[
                private void locateApple() {

                    int r = (int) (Math.random() * RAND_POS);
                    apple_x = ((r * DOT_SIZE));
            
                    r = (int) (Math.random() * RAND_POS);
                    apple_y = ((r * DOT_SIZE));
                }
            ]]></programlisting>
            Az almák elhelyezése teljesen randomizált módon történik. A randomszám generáláshoz a Java saját <function>random</function> függvényét használjuk.
            <programlisting language="java"><![CDATA[
                private void move() {

                    for (int z = dots; z > 0; z--) {
                        x[z] = x[(z - 1)];
                        y[z] = y[(z - 1)];
                    }
            
                    if (leftDirection) {
                        x[0] -= DOT_SIZE;
                    }
            
                    if (rightDirection) {
                        x[0] += DOT_SIZE;
                    }
            
                    if (upDirection) {
                        y[0] -= DOT_SIZE;
                    }
            
                    if (downDirection) {
                        y[0] += DOT_SIZE;
                    }
                }
            ]]></programlisting>
            A kígyó mozgatása mögötti mechanizmust a <function>move</function> függvény adja meg. A mozgáson kívül kezelni kell még a ütközésket mind önmagával, mind 
            a fallal. Erre szolgál a <function>checkCollision</function> függvény.
            <programlisting language="java"><![CDATA[
                private void checkCollision() {

                    for (int z = dots; z > 0; z--) {
            
                        if ((z > 4) && (x[0] == x[z]) && (y[0] == y[z])) {
                            inGame = false;
                        }
                    }
            
                    if (y[0] >= B_HEIGHT) {
                        inGame = false;
                    }
            
                    if (y[0] < 0) {
                        inGame = false;
                    }
            
                    if (x[0] >= B_WIDTH) {
                        inGame = false;
                    }
            
                    if (x[0] < 0) {
                        inGame = false;
                    }
                    
                    if (!inGame) {
                        timer.stop();
                    }
                }
            ]]></programlisting>
            Csak akkir tudja megharapni magát, ha már legalább 5 egység hosszú, ebben az esetben az kell vizsgálni, hogy van-e
            olyan pont, aminek megegyezik a pozíciója a fej pozíciójával. Ha 5-nál kisebb, akkor csak a 
            "falat" nem szabad elérnie, tehát a képernyő szélét. Mindegyik hiba azt okozza, hogy a játék véget ér. 
            <programlisting language="java"><![CDATA[
                private void checkApple() {

                    if ((x[0] == apple_x) && (y[0] == apple_y)) {
            
                        dots++;
                        locateApple();
                    }
                }
            ]]></programlisting>
            Azt, hogy a kígyó mérete milyen módon nő, azt a <function>checkApple</function> függvény határozza meg. Akkor vesszük úgy, hogy a 
            kígyó megette az almát, ha a kígyó feje, és az alma pozíciója egyezik. Ha ez teljesül, akkor növeljük a kígyó hosszát, és generálunk egy
            új almát.
        </para>
        <para>
            A <filename>Snake.java</filename> elég rövid, abban nem is történt semmi módosítás.
            <programlisting language="java"><![CDATA[
                public class Snake extends JFrame {

                    public Snake() {
                        
                        initUI();
                    }
                    
                    private void initUI() {
                        
                        Board m_board = new Board();
                        
                        add(m_board);
                               
                        setAlwaysOnTop(true);
                        setResizable(false);
                        pack();
                        
                        setLocationRelativeTo(null);
                        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                    }
                    
                
                    public static void main(String[] args) {
                        
                        EventQueue.invokeLater(() -> {
                            JFrame ex = new Snake();
                            ex.setVisible(true);
                        });
                    }
                }
            ]]></programlisting>
            A <function>Snake</function> osztály a <function>JFrame</function> osztály leszármazottja. Komolyabb feladatot nem lát el, 
            csak felületet biztosít, amire ráhelyezzük a <function>Board</function> objektumot. És ez az osztály tartalmazz a 
            <function>main</function> függvényt is, tehát itt indul a program futása. 
        </para>
    </section>        
    
    <section>
        <title>Paszigráfia Rapszódia OpenGL full screen vizualizáció</title>
        <para>
            Lásd vis_prel_para.pdf! Apró módosításokat eszközölj benne, pl. színvilág, textúrázás, a szintek jobb
            elkülönítése, kézreállóbb irányítás.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        

    <section>
        <title>Paszigráfia Rapszódia LuaLaTeX vizualizáció</title>
        <para>
            Lásd vis_prel_para.pdf! Apró módosításokat eszközölj benne, pl. színvilág, még erősebb 3D-s hatás.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
    </section>        

    <section>
        <title>Perceptron osztály</title>
        <para>
            Dolgozzuk be egy külön projektbe a projekt Perceptron osztályát!
            Lásd <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            <emphasis role="strong">Tanulságok, tapasztalatok, magyarázat...</emphasis>
        </para>
        <para>
            Korábbi részben már taglaltuk, hogy mi is az a perceptron. A Perceptron arra szolgál, hogy kétfelé válassza a 
            bemneteket, emiatt Lineáris Bináris Osztályozónak is szokták nevezni. Egy perceptron részei a bemenetek és a hozzájuk 
            tartozó súlyok, az összegző csomópont, az aktivációs függvény és a kimenet.
            <figure>
                <title>Perceptron felépítése</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../../attention_raising/Source/Saját_perceptron/figperc.png" format="PNG"/>
                        </imageobject>
                    </mediaobject>
            </figure>
            Ezt a implementálja a <function>Perceptron</function> soztályunk, ami az <filename>ml.hpp</filename>-ben található.
            <programlisting><![CDATA[
    class Perceptron
    {
    public:
        Perceptron ( int nof, ... )
        {
            n_layers = nof;
            
            units = new double*[n_layers];
            n_units = new int[n_layers];
            
            va_list vap;
            
            va_start ( vap, nof );
            
            for ( int i {0}; i < n_layers; ++i )
            {
                n_units[i] = va_arg ( vap, int );
                
                if ( i )
                    units[i] = new double [n_units[i]];
            }
            
            va_end ( vap );
            
            weights = new double**[n_layers-1];
            
            #ifndef RND_DEBUG
            std::random_device init;
            std::default_random_engine gen {init() };
            #else
            std::default_random_engine gen;
            #endif
            
            std::uniform_real_distribution<double> dist ( -1.0, 1.0 );
            
            for ( int i {1}; i < n_layers; ++i )
            {
                weights[i-1] = new double *[n_units[i]];
                
                for ( int j {0}; j < n_units[i]; ++j )
                {
                    weights[i-1][j] = new double [n_units[i-1]];
                    
                    for ( int k {0}; k < n_units[i-1]; ++k )
                    {
                        weights[i-1][j][k] = dist ( gen );
                    }
                }
            }
        }
        
        Perceptron ( std::fstream & file )
        {
            file >> n_layers;
            
            units = new double*[n_layers];
            n_units = new int[n_layers];
            
            for ( int i {0}; i < n_layers; ++i )
            {
                file >> n_units[i];
                
                if ( i )
                    units[i] = new double [n_units[i]];
            }
            
            weights = new double**[n_layers-1];
            
            for ( int i {1}; i < n_layers; ++i )
            {
                weights[i-1] = new double *[n_units[i]];
                
                for ( int j {0}; j < n_units[i]; ++j )
                {
                    weights[i-1][j] = new double [n_units[i-1]];
                    
                    for ( int k {0}; k < n_units[i-1]; ++k )
                    {
                        file >> weights[i-1][j][k];
                    }
                }
            }
        }
        
        
        double sigmoid ( double x )
        {
            return 1.0/ ( 1.0 + exp ( -x ) );
        }
        
        
        double operator() ( double image [] )
        {
            
            units[0] = image;
            
            for ( int i {1}; i < n_layers; ++i )
            {
                
                #ifdef CUDA_PRCPS
                
                cuda_layer ( i, n_units, units, weights );
                
                #else
                
                #pragma omp parallel for
                for ( int j = 0; j < n_units[i]; ++j )
                {
                    units[i][j] = 0.0;
                    
                    for ( int k = 0; k < n_units[i-1]; ++k )
                    {
                        units[i][j] += weights[i-1][j][k] * units[i-1][k];
                    }
                    
                    units[i][j] = sigmoid ( units[i][j] );
                    
                }
                
                #endif
                
            }
            
            return sigmoid ( units[n_layers - 1][0] );
            
        }
        
        void learning ( double image [], double q, double prev_q )
        {
            double y[1] {q};
            
            learning ( image, y );
        }
        
        void learning ( double image [], double y[] )
        {
            //( *this ) ( image );
            
            units[0] = image;
            
            double ** backs = new double*[n_layers-1];
            
            for ( int i {0}; i < n_layers-1; ++i )
            {
                backs[i] = new double [n_units[i+1]];
            }
            
            int i {n_layers-1};
            
            for ( int j {0}; j < n_units[i]; ++j )
            {
                backs[i-1][j] = sigmoid ( units[i][j] ) * ( 1.0-sigmoid ( units[i][j] ) ) * ( y[j] - units[i][j] );
                
                for ( int k {0}; k < n_units[i-1]; ++k )
                {
                    weights[i-1][j][k] += ( 0.2* backs[i-1][j] *units[i-1][k] );
                }
                
            }
            
            for ( int i {n_layers-2}; i >0 ; --i )
            {
                
                #pragma omp parallel for
                for ( int j =0; j < n_units[i]; ++j )
                {
                    
                    double sum = 0.0;
                    
                    for ( int l = 0; l < n_units[i+1]; ++l )
                    {
                        sum += 0.19*weights[i][l][j]*backs[i][l];
                    }
                    
                    backs[i-1][j] = sigmoid ( units[i][j] ) * ( 1.0-sigmoid ( units[i][j] ) ) * sum;
                    
                    for ( int k = 0; k < n_units[i-1]; ++k )
                    {
                        weights[i-1][j][k] += ( 0.19* backs[i-1][j] *units[i-1][k] );
                    }
                }
            }
            
            for ( int i {0}; i < n_layers-1; ++i )
            {
                delete [] backs[i];
            }
            
            delete [] backs;
            
        }
        
        ~Perceptron()
        {
            for ( int i {1}; i < n_layers; ++i )
            {
                for ( int j {0}; j < n_units[i]; ++j )
                {
                    delete [] weights[i-1][j];
                }
                
                delete [] weights[i-1];
            }
            
            delete [] weights;
            
            for ( int i {0}; i < n_layers; ++i )
            {
                if ( i )
                    delete [] units[i];
            }
            
            delete [] units;
            delete [] n_units;
            
        }
        
        void save ( std::fstream & out )
        {
            out << " "
            << n_layers;
            
            for ( int i {0}; i < n_layers; ++i )
                out << " " << n_units[i];
                
                for ( int i {1}; i < n_layers; ++i )
                {
                    for ( int j {0}; j < n_units[i]; ++j )
                    {
                        for ( int k {0}; k < n_units[i-1]; ++k )
                        {
                            out << " "
                            << weights[i-1][j][k];
                            
                        }
                    }
                }
                
        }
        
    private:
        Perceptron ( const Perceptron & );
        Perceptron & operator= ( const Perceptron & );
        
        int n_layers;
        int* n_units;
        double **units;
        double ***weights;
        
    };
            ]]></programlisting>
            A régi programot fogjuk egy kicsit módosítani, természetesen a <function>Perceptron</function> osztály érintetlen marad.
            Korábban csak egy számot kaptunk végeredményül, most lesz egy képi kimenetünk is. 
            A módosítás a következő:
            <programlisting language="c++"><![CDATA[
                srand(time(nullptr));

                for(int i = 0; i < png_image.get_width(); ++i)
                    for(int j = 0; j<png_image.get_height(); ++j){
                        png_image[i][j].green = rand()%256;//newPNG[j*png_image.get_height()+j];
                    }
                png_image.write("output.png");            
            ]]></programlisting>
            A lényeg, hogy vesszük a beolvasott képet, és annak az egyes pixeleinek a zöld elemét változtatjuk random.
            De rengeteg féleképpen lehet ezt megoldani, változtathatjuk a pixel kék és piros komponenseit is, vagy azt is
            lehet, hogy csak elvonunk színeket az egyes pixelektől, azaz kinullázzuk.
            <programlisting language="c++"><![CDATA[
                double* newPNG = new double[size];
            
                for(int i = 0; i < png_image.get_width(); ++i)
                    for(int j = 0; j<png_image.get_height(); ++j){
                        png_image[i][j].green = newPNG[j*png_image.get_height()+j];
                    }
                png_image.write("output.png");
            ]]></programlisting>
            Lényegében ebben az esetben van egy tömbünk csupa nullából, és ebből kiválasztjuk az adott elemet, amivel kinullázzuk az R,G,B valamelyikét.
            De az látható, hogy nem is lenne feltétlen szükség tömbre. Ha ki szeretnénk nullázni, akkor elég ez is:
            <programlisting language="c++">
                png_image[i][j].green = 0;
            </programlisting>
        </para>
    </section>
</chapter>                
